
Fusebox_Firmware.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000000a  00800100  000007e8  0000087c  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         000007e8  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000021  0080010a  0080010a  00000886  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00000886  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  000008b8  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000138  00000000  00000000  000008f8  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00001617  00000000  00000000  00000a30  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000ee6  00000000  00000000  00002047  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00000bf5  00000000  00000000  00002f2d  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  0000029c  00000000  00000000  00003b24  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000008d4  00000000  00000000  00003dc0  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000004d7  00000000  00000000  00004694  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000000d8  00000000  00000000  00004b6b  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	49 c0       	rjmp	.+146    	; 0x94 <__ctors_end>
   2:	00 00       	nop
   4:	64 c0       	rjmp	.+200    	; 0xce <__bad_interrupt>
   6:	00 00       	nop
   8:	62 c0       	rjmp	.+196    	; 0xce <__bad_interrupt>
   a:	00 00       	nop
   c:	60 c0       	rjmp	.+192    	; 0xce <__bad_interrupt>
   e:	00 00       	nop
  10:	5e c0       	rjmp	.+188    	; 0xce <__bad_interrupt>
  12:	00 00       	nop
  14:	5c c0       	rjmp	.+184    	; 0xce <__bad_interrupt>
  16:	00 00       	nop
  18:	5a c0       	rjmp	.+180    	; 0xce <__bad_interrupt>
  1a:	00 00       	nop
  1c:	58 c0       	rjmp	.+176    	; 0xce <__bad_interrupt>
  1e:	00 00       	nop
  20:	56 c0       	rjmp	.+172    	; 0xce <__bad_interrupt>
  22:	00 00       	nop
  24:	a6 c3       	rjmp	.+1868   	; 0x772 <__vector_9>
  26:	00 00       	nop
  28:	52 c0       	rjmp	.+164    	; 0xce <__bad_interrupt>
  2a:	00 00       	nop
  2c:	50 c0       	rjmp	.+160    	; 0xce <__bad_interrupt>
  2e:	00 00       	nop
  30:	ba c1       	rjmp	.+884    	; 0x3a6 <__vector_12>
  32:	00 00       	nop
  34:	4c c0       	rjmp	.+152    	; 0xce <__bad_interrupt>
  36:	00 00       	nop
  38:	4a c0       	rjmp	.+148    	; 0xce <__bad_interrupt>
  3a:	00 00       	nop
  3c:	48 c0       	rjmp	.+144    	; 0xce <__bad_interrupt>
  3e:	00 00       	nop
  40:	62 c3       	rjmp	.+1732   	; 0x706 <__vector_16>
  42:	00 00       	nop
  44:	44 c0       	rjmp	.+136    	; 0xce <__bad_interrupt>
  46:	00 00       	nop
  48:	42 c0       	rjmp	.+132    	; 0xce <__bad_interrupt>
  4a:	00 00       	nop
  4c:	40 c0       	rjmp	.+128    	; 0xce <__bad_interrupt>
  4e:	00 00       	nop
  50:	3e c0       	rjmp	.+124    	; 0xce <__bad_interrupt>
  52:	00 00       	nop
  54:	3c c0       	rjmp	.+120    	; 0xce <__bad_interrupt>
  56:	00 00       	nop
  58:	3a c0       	rjmp	.+116    	; 0xce <__bad_interrupt>
  5a:	00 00       	nop
  5c:	38 c0       	rjmp	.+112    	; 0xce <__bad_interrupt>
  5e:	00 00       	nop
  60:	36 c0       	rjmp	.+108    	; 0xce <__bad_interrupt>
  62:	00 00       	nop
  64:	44 c0       	rjmp	.+136    	; 0xee <__vector_25>
  66:	00 00       	nop
  68:	32 c0       	rjmp	.+100    	; 0xce <__bad_interrupt>
  6a:	00 00       	nop
  6c:	30 c0       	rjmp	.+96     	; 0xce <__bad_interrupt>
  6e:	00 00       	nop
  70:	2e c0       	rjmp	.+92     	; 0xce <__bad_interrupt>
  72:	00 00       	nop
  74:	2c c0       	rjmp	.+88     	; 0xce <__bad_interrupt>
  76:	00 00       	nop
  78:	2a c0       	rjmp	.+84     	; 0xce <__bad_interrupt>
  7a:	00 00       	nop
  7c:	28 c0       	rjmp	.+80     	; 0xce <__bad_interrupt>
  7e:	00 00       	nop
  80:	26 c0       	rjmp	.+76     	; 0xce <__bad_interrupt>
  82:	00 00       	nop
  84:	24 c0       	rjmp	.+72     	; 0xce <__bad_interrupt>
  86:	00 00       	nop
  88:	22 c0       	rjmp	.+68     	; 0xce <__bad_interrupt>
  8a:	00 00       	nop
  8c:	20 c0       	rjmp	.+64     	; 0xce <__bad_interrupt>
  8e:	00 00       	nop
  90:	1e c0       	rjmp	.+60     	; 0xce <__bad_interrupt>
	...

00000094 <__ctors_end>:
  94:	11 24       	eor	r1, r1
  96:	1f be       	out	0x3f, r1	; 63
  98:	cf ef       	ldi	r28, 0xFF	; 255
  9a:	d0 e1       	ldi	r29, 0x10	; 16
  9c:	de bf       	out	0x3e, r29	; 62
  9e:	cd bf       	out	0x3d, r28	; 61

000000a0 <__do_copy_data>:
  a0:	11 e0       	ldi	r17, 0x01	; 1
  a2:	a0 e0       	ldi	r26, 0x00	; 0
  a4:	b1 e0       	ldi	r27, 0x01	; 1
  a6:	e8 ee       	ldi	r30, 0xE8	; 232
  a8:	f7 e0       	ldi	r31, 0x07	; 7
  aa:	00 e0       	ldi	r16, 0x00	; 0
  ac:	0b bf       	out	0x3b, r16	; 59
  ae:	02 c0       	rjmp	.+4      	; 0xb4 <__do_copy_data+0x14>
  b0:	07 90       	elpm	r0, Z+
  b2:	0d 92       	st	X+, r0
  b4:	aa 30       	cpi	r26, 0x0A	; 10
  b6:	b1 07       	cpc	r27, r17
  b8:	d9 f7       	brne	.-10     	; 0xb0 <__do_copy_data+0x10>

000000ba <__do_clear_bss>:
  ba:	21 e0       	ldi	r18, 0x01	; 1
  bc:	aa e0       	ldi	r26, 0x0A	; 10
  be:	b1 e0       	ldi	r27, 0x01	; 1
  c0:	01 c0       	rjmp	.+2      	; 0xc4 <.do_clear_bss_start>

000000c2 <.do_clear_bss_loop>:
  c2:	1d 92       	st	X+, r1

000000c4 <.do_clear_bss_start>:
  c4:	ab 32       	cpi	r26, 0x2B	; 43
  c6:	b2 07       	cpc	r27, r18
  c8:	e1 f7       	brne	.-8      	; 0xc2 <.do_clear_bss_loop>
  ca:	82 d1       	rcall	.+772    	; 0x3d0 <main>
  cc:	8b c3       	rjmp	.+1814   	; 0x7e4 <_exit>

000000ce <__bad_interrupt>:
  ce:	98 cf       	rjmp	.-208    	; 0x0 <__vectors>

000000d0 <adc_config>:
uint8_t adc_next = 0;



void adc_config(){
	ADMUX = (1<<REFS0); // AREF = AVcc and PF0 (ADC0) as input defined
  d0:	80 e4       	ldi	r24, 0x40	; 64
  d2:	80 93 7c 00 	sts	0x007C, r24	; 0x80007c <__TEXT_REGION_LENGTH__+0x7e007c>
	ADCSRA = (1<<ADEN) | (1<<ADPS2) | (0<<ADPS1) | (0<<ADPS0) | (1<<ADIE);
  d6:	ea e7       	ldi	r30, 0x7A	; 122
  d8:	f0 e0       	ldi	r31, 0x00	; 0
  da:	8c e8       	ldi	r24, 0x8C	; 140
  dc:	80 83       	st	Z, r24
	// ADEN enables ADC
	// ADIE enables ADC interrupt
	// ADPS (Prescaler) 16
	// see datasheet page 290
	ADCSRA |= (1<<ADSC); //start first conversion
  de:	80 81       	ld	r24, Z
  e0:	80 64       	ori	r24, 0x40	; 64
  e2:	80 83       	st	Z, r24
  e4:	08 95       	ret

000000e6 <adc_start_conversion>:
}

void adc_start_conversion(){
	//start next conversion with same config
	ADCSRA = (1<<ADEN) | (1<<ADIE) | (1<<ADSC);
  e6:	88 ec       	ldi	r24, 0xC8	; 200
  e8:	80 93 7a 00 	sts	0x007A, r24	; 0x80007a <__TEXT_REGION_LENGTH__+0x7e007a>
  ec:	08 95       	ret

000000ee <__vector_25>:
}

ISR(ADC_vect){
  ee:	1f 92       	push	r1
  f0:	0f 92       	push	r0
  f2:	0f b6       	in	r0, 0x3f	; 63
  f4:	0f 92       	push	r0
  f6:	11 24       	eor	r1, r1
  f8:	0b b6       	in	r0, 0x3b	; 59
  fa:	0f 92       	push	r0
  fc:	2f 93       	push	r18
  fe:	3f 93       	push	r19
 100:	4f 93       	push	r20
 102:	5f 93       	push	r21
 104:	6f 93       	push	r22
 106:	7f 93       	push	r23
 108:	8f 93       	push	r24
 10a:	9f 93       	push	r25
 10c:	af 93       	push	r26
 10e:	bf 93       	push	r27
 110:	ef 93       	push	r30
 112:	ff 93       	push	r31
	//cli();
	// store ADC result
	adc_values[adc_next] = ADC;// ADCL | (ADCH << 8); //low bit erst ablesen
 114:	80 91 0a 01 	lds	r24, 0x010A	; 0x80010a <__data_end>
 118:	e8 2f       	mov	r30, r24
 11a:	f0 e0       	ldi	r31, 0x00	; 0
 11c:	20 91 78 00 	lds	r18, 0x0078	; 0x800078 <__TEXT_REGION_LENGTH__+0x7e0078>
 120:	30 91 79 00 	lds	r19, 0x0079	; 0x800079 <__TEXT_REGION_LENGTH__+0x7e0079>
 124:	ee 0f       	add	r30, r30
 126:	ff 1f       	adc	r31, r31
 128:	ea 5d       	subi	r30, 0xDA	; 218
 12a:	fe 4f       	sbci	r31, 0xFE	; 254
 12c:	31 83       	std	Z+1, r19	; 0x01
 12e:	20 83       	st	Z, r18
	adc_next++;
 130:	8f 5f       	subi	r24, 0xFF	; 255
 132:	80 93 0a 01 	sts	0x010A, r24	; 0x80010a <__data_end>
	//adc_values[0] = (ADC*5)/1023;  //cant decide where in the code this should go without testing
	//adc_values[1] = ((ADC*5)/1023)+((10000*(ADC*5)/1023)/2500); //no way this is efficient, needs to be optimized later
	// reset index var
	//sei();
	if(adc_next == ADCVALUES){
 136:	82 30       	cpi	r24, 0x02	; 2
 138:	11 f4       	brne	.+4      	; 0x13e <__vector_25+0x50>
		adc_next = 0;
 13a:	10 92 0a 01 	sts	0x010A, r1	; 0x80010a <__data_end>
	}
	// select other ADC Input
	ADMUX = (1<<REFS0) | adc_next;
 13e:	80 91 0a 01 	lds	r24, 0x010A	; 0x80010a <__data_end>
 142:	80 64       	ori	r24, 0x40	; 64
 144:	80 93 7c 00 	sts	0x007C, r24	; 0x80007c <__TEXT_REGION_LENGTH__+0x7e007c>

	adc_start_conversion();
 148:	ce df       	rcall	.-100    	; 0xe6 <adc_start_conversion>
	//sei();
}
 14a:	ff 91       	pop	r31
 14c:	ef 91       	pop	r30
 14e:	bf 91       	pop	r27
 150:	af 91       	pop	r26
 152:	9f 91       	pop	r25
 154:	8f 91       	pop	r24
 156:	7f 91       	pop	r23
 158:	6f 91       	pop	r22
 15a:	5f 91       	pop	r21
 15c:	4f 91       	pop	r20
 15e:	3f 91       	pop	r19
 160:	2f 91       	pop	r18
 162:	0f 90       	pop	r0
 164:	0b be       	out	0x3b, r0	; 59
 166:	0f 90       	pop	r0
 168:	0f be       	out	0x3f, r0	; 63
 16a:	0f 90       	pop	r0
 16c:	1f 90       	pop	r1
 16e:	18 95       	reti

00000170 <adc_get>:

// getter for each adc var
uint16_t adc_get(uint8_t adc){
	
	return adc_values[adc];
 170:	e8 2f       	mov	r30, r24
 172:	f0 e0       	ldi	r31, 0x00	; 0
 174:	ee 0f       	add	r30, r30
 176:	ff 1f       	adc	r31, r31
 178:	ea 5d       	subi	r30, 0xDA	; 218
 17a:	fe 4f       	sbci	r31, 0xFE	; 254
}
 17c:	80 81       	ld	r24, Z
 17e:	91 81       	ldd	r25, Z+1	; 0x01
 180:	08 95       	ret

00000182 <can_check_free>:

uint8_t can_check_free(uint8_t mobnum){
	
	uint8_t mob_status = 0;
	
	if(mobnum >7){
 182:	88 30       	cpi	r24, 0x08	; 8
 184:	78 f0       	brcs	.+30     	; 0x1a4 <can_check_free+0x22>
		
		mob_status = !((CANEN1 >> (mobnum-8)) &1);
 186:	20 91 dd 00 	lds	r18, 0x00DD	; 0x8000dd <__TEXT_REGION_LENGTH__+0x7e00dd>
 18a:	90 e0       	ldi	r25, 0x00	; 0
 18c:	08 97       	sbiw	r24, 0x08	; 8
 18e:	30 e0       	ldi	r19, 0x00	; 0
 190:	02 c0       	rjmp	.+4      	; 0x196 <can_check_free+0x14>
 192:	35 95       	asr	r19
 194:	27 95       	ror	r18
 196:	8a 95       	dec	r24
 198:	e2 f7       	brpl	.-8      	; 0x192 <can_check_free+0x10>
 19a:	81 e0       	ldi	r24, 0x01	; 1
 19c:	20 ff       	sbrs	r18, 0
 19e:	0d c0       	rjmp	.+26     	; 0x1ba <can_check_free+0x38>
 1a0:	80 e0       	ldi	r24, 0x00	; 0
 1a2:	08 95       	ret


		} else {
		
		mob_status = !((CANEN2 >> mobnum) &1);
 1a4:	20 91 dc 00 	lds	r18, 0x00DC	; 0x8000dc <__TEXT_REGION_LENGTH__+0x7e00dc>
 1a8:	30 e0       	ldi	r19, 0x00	; 0
 1aa:	02 c0       	rjmp	.+4      	; 0x1b0 <can_check_free+0x2e>
 1ac:	35 95       	asr	r19
 1ae:	27 95       	ror	r18
 1b0:	8a 95       	dec	r24
 1b2:	e2 f7       	brpl	.-8      	; 0x1ac <can_check_free+0x2a>
 1b4:	81 e0       	ldi	r24, 0x01	; 1
 1b6:	20 fd       	sbrc	r18, 0
 1b8:	80 e0       	ldi	r24, 0x00	; 0
	}

	return mob_status;
	
}
 1ba:	08 95       	ret

000001bc <can_cfg>:
void can_cfg(){
	
	CANGCON = 0; // Disable CAN
 1bc:	10 92 d8 00 	sts	0x00D8, r1	; 0x8000d8 <__TEXT_REGION_LENGTH__+0x7e00d8>
	
	for (uint8_t mob = 0; mob < 15 ; mob++){//reset all mobs
 1c0:	40 e0       	ldi	r20, 0x00	; 0
 1c2:	29 c0       	rjmp	.+82     	; 0x216 <can_cfg+0x5a>
		CANPAGE = mob<<MOBNB0 | (1<<AINC);
 1c4:	80 e1       	ldi	r24, 0x10	; 16
 1c6:	48 9f       	mul	r20, r24
 1c8:	90 01       	movw	r18, r0
 1ca:	11 24       	eor	r1, r1
 1cc:	82 2f       	mov	r24, r18
 1ce:	88 60       	ori	r24, 0x08	; 8
 1d0:	80 93 ed 00 	sts	0x00ED, r24	; 0x8000ed <__TEXT_REGION_LENGTH__+0x7e00ed>
		CANSTMOB = 0;
 1d4:	10 92 ee 00 	sts	0x00EE, r1	; 0x8000ee <__TEXT_REGION_LENGTH__+0x7e00ee>
		CANCDMOB = 0;
 1d8:	10 92 ef 00 	sts	0x00EF, r1	; 0x8000ef <__TEXT_REGION_LENGTH__+0x7e00ef>
		CANIDT4 = 0;
 1dc:	10 92 f0 00 	sts	0x00F0, r1	; 0x8000f0 <__TEXT_REGION_LENGTH__+0x7e00f0>
		CANIDT3 = 0;
 1e0:	10 92 f1 00 	sts	0x00F1, r1	; 0x8000f1 <__TEXT_REGION_LENGTH__+0x7e00f1>
		CANIDT2 = 0;
 1e4:	10 92 f2 00 	sts	0x00F2, r1	; 0x8000f2 <__TEXT_REGION_LENGTH__+0x7e00f2>
		CANIDT1 = 0;
 1e8:	10 92 f3 00 	sts	0x00F3, r1	; 0x8000f3 <__TEXT_REGION_LENGTH__+0x7e00f3>
		CANIDM4 = 0;
 1ec:	10 92 f4 00 	sts	0x00F4, r1	; 0x8000f4 <__TEXT_REGION_LENGTH__+0x7e00f4>
		CANIDM3 = 0;
 1f0:	10 92 f5 00 	sts	0x00F5, r1	; 0x8000f5 <__TEXT_REGION_LENGTH__+0x7e00f5>
		CANIDM2 = 0;
 1f4:	10 92 f6 00 	sts	0x00F6, r1	; 0x8000f6 <__TEXT_REGION_LENGTH__+0x7e00f6>
		CANIDM1 = 0;
 1f8:	10 92 f7 00 	sts	0x00F7, r1	; 0x8000f7 <__TEXT_REGION_LENGTH__+0x7e00f7>
		for (uint8_t byte = 0; byte < 8; byte++){
 1fc:	80 e0       	ldi	r24, 0x00	; 0
 1fe:	08 c0       	rjmp	.+16     	; 0x210 <can_cfg+0x54>
			CANPAGE = mob<<MOBNB0 | 1<<AINC | byte;
 200:	98 2f       	mov	r25, r24
 202:	92 2b       	or	r25, r18
 204:	98 60       	ori	r25, 0x08	; 8
 206:	90 93 ed 00 	sts	0x00ED, r25	; 0x8000ed <__TEXT_REGION_LENGTH__+0x7e00ed>
			CANMSG = 0;
 20a:	10 92 fa 00 	sts	0x00FA, r1	; 0x8000fa <__TEXT_REGION_LENGTH__+0x7e00fa>
		CANIDT1 = 0;
		CANIDM4 = 0;
		CANIDM3 = 0;
		CANIDM2 = 0;
		CANIDM1 = 0;
		for (uint8_t byte = 0; byte < 8; byte++){
 20e:	8f 5f       	subi	r24, 0xFF	; 255
 210:	88 30       	cpi	r24, 0x08	; 8
 212:	b0 f3       	brcs	.-20     	; 0x200 <can_cfg+0x44>
}
void can_cfg(){
	
	CANGCON = 0; // Disable CAN
	
	for (uint8_t mob = 0; mob < 15 ; mob++){//reset all mobs
 214:	4f 5f       	subi	r20, 0xFF	; 255
 216:	4f 30       	cpi	r20, 0x0F	; 15
 218:	a8 f2       	brcs	.-86     	; 0x1c4 <can_cfg+0x8>
			CANPAGE = mob<<MOBNB0 | 1<<AINC | byte;
			CANMSG = 0;
		}
	}

	CANBT1 = 0x00;// Set Baudrate
 21a:	10 92 e2 00 	sts	0x00E2, r1	; 0x8000e2 <__TEXT_REGION_LENGTH__+0x7e00e2>
	CANBT2 = 0x0C;// 500kBaud according
 21e:	8c e0       	ldi	r24, 0x0C	; 12
 220:	80 93 e3 00 	sts	0x00E3, r24	; 0x8000e3 <__TEXT_REGION_LENGTH__+0x7e00e3>
	CANBT3 = 0x36;// to Datasheet S. 267
 224:	86 e3       	ldi	r24, 0x36	; 54
 226:	80 93 e4 00 	sts	0x00E4, r24	; 0x8000e4 <__TEXT_REGION_LENGTH__+0x7e00e4>

	CANGIE = 0;
 22a:	10 92 db 00 	sts	0x00DB, r1	; 0x8000db <__TEXT_REGION_LENGTH__+0x7e00db>

	CANGCON |= (1<<ENASTB); // Enable CAN
 22e:	e8 ed       	ldi	r30, 0xD8	; 216
 230:	f0 e0       	ldi	r31, 0x00	; 0
 232:	80 81       	ld	r24, Z
 234:	82 60       	ori	r24, 0x02	; 2
 236:	80 83       	st	Z, r24
 238:	08 95       	ret

0000023a <can_rx>:
	
	
	
}
void can_rx(struct CAN_MOB *to_receive, uint8_t *data){
 23a:	0f 93       	push	r16
 23c:	1f 93       	push	r17
 23e:	cf 93       	push	r28
 240:	df 93       	push	r29
 242:	ec 01       	movw	r28, r24
 244:	8b 01       	movw	r16, r22
	
	CANPAGE = to_receive->mob_number << MOBNB0;
 246:	8c 81       	ldd	r24, Y+4	; 0x04
 248:	82 95       	swap	r24
 24a:	80 7f       	andi	r24, 0xF0	; 240
 24c:	80 93 ed 00 	sts	0x00ED, r24	; 0x8000ed <__TEXT_REGION_LENGTH__+0x7e00ed>
	if (can_check_free(to_receive->mob_number)){
 250:	8c 81       	ldd	r24, Y+4	; 0x04
 252:	97 df       	rcall	.-210    	; 0x182 <can_check_free>
 254:	88 23       	and	r24, r24
 256:	71 f1       	breq	.+92     	; 0x2b4 <can_rx+0x7a>
		/* load the id 11 bit */
		CANIDT1 = to_receive->mob_id >>3;
 258:	88 81       	ld	r24, Y
 25a:	99 81       	ldd	r25, Y+1	; 0x01
 25c:	96 95       	lsr	r25
 25e:	87 95       	ror	r24
 260:	96 95       	lsr	r25
 262:	87 95       	ror	r24
 264:	96 95       	lsr	r25
 266:	87 95       	ror	r24
 268:	80 93 f3 00 	sts	0x00F3, r24	; 0x8000f3 <__TEXT_REGION_LENGTH__+0x7e00f3>
		CANIDT2 = (to_receive->mob_id << 5)&0b11100000;
 26c:	88 81       	ld	r24, Y
 26e:	82 95       	swap	r24
 270:	88 0f       	add	r24, r24
 272:	80 7e       	andi	r24, 0xE0	; 224
 274:	80 93 f2 00 	sts	0x00F2, r24	; 0x8000f2 <__TEXT_REGION_LENGTH__+0x7e00f2>
		CANIDT3 = 0;
 278:	10 92 f1 00 	sts	0x00F1, r1	; 0x8000f1 <__TEXT_REGION_LENGTH__+0x7e00f1>
		CANIDT4 = 1<<RTRTAG;
 27c:	84 e0       	ldi	r24, 0x04	; 4
 27e:	80 93 f0 00 	sts	0x00F0, r24	; 0x8000f0 <__TEXT_REGION_LENGTH__+0x7e00f0>
		CANIDM1 = to_receive->mob_idmask >>3;
 282:	8a 81       	ldd	r24, Y+2	; 0x02
 284:	9b 81       	ldd	r25, Y+3	; 0x03
 286:	96 95       	lsr	r25
 288:	87 95       	ror	r24
 28a:	96 95       	lsr	r25
 28c:	87 95       	ror	r24
 28e:	96 95       	lsr	r25
 290:	87 95       	ror	r24
 292:	80 93 f7 00 	sts	0x00F7, r24	; 0x8000f7 <__TEXT_REGION_LENGTH__+0x7e00f7>
		CANIDM2 = (to_receive->mob_idmask <<5)&0b11100000;
 296:	8a 81       	ldd	r24, Y+2	; 0x02
 298:	82 95       	swap	r24
 29a:	88 0f       	add	r24, r24
 29c:	80 7e       	andi	r24, 0xE0	; 224
 29e:	80 93 f6 00 	sts	0x00F6, r24	; 0x8000f6 <__TEXT_REGION_LENGTH__+0x7e00f6>
		CANIDM3 = 0;
 2a2:	10 92 f5 00 	sts	0x00F5, r1	; 0x8000f5 <__TEXT_REGION_LENGTH__+0x7e00f5>
		CANIDM4 = 0;
 2a6:	10 92 f4 00 	sts	0x00F4, r1	; 0x8000f4 <__TEXT_REGION_LENGTH__+0x7e00f4>
		CANCDMOB = (1 << CONMOB1) | (1 << CONMOB0)| (1<<DLC3);
 2aa:	88 ec       	ldi	r24, 0xC8	; 200
 2ac:	80 93 ef 00 	sts	0x00EF, r24	; 0x8000ef <__TEXT_REGION_LENGTH__+0x7e00ef>
		CANSTMOB = 0;
 2b0:	10 92 ee 00 	sts	0x00EE, r1	; 0x8000ee <__TEXT_REGION_LENGTH__+0x7e00ee>
	CANGCON |= (1<<ENASTB); // Enable CAN
	
	
	
}
void can_rx(struct CAN_MOB *to_receive, uint8_t *data){
 2b4:	20 e0       	ldi	r18, 0x00	; 0
 2b6:	10 c0       	rjmp	.+32     	; 0x2d8 <can_rx+0x9e>
		CANCDMOB = (1 << CONMOB1) | (1 << CONMOB0)| (1<<DLC3);
		CANSTMOB = 0;
	}
	
	for(uint8_t byte = 0; byte <8; byte++){
		CANPAGE = (to_receive->mob_number << MOBNB0) | (1 << AINC) | byte;
 2b8:	8c 81       	ldd	r24, Y+4	; 0x04
 2ba:	30 e1       	ldi	r19, 0x10	; 16
 2bc:	83 9f       	mul	r24, r19
 2be:	c0 01       	movw	r24, r0
 2c0:	11 24       	eor	r1, r1
 2c2:	82 2b       	or	r24, r18
 2c4:	88 60       	ori	r24, 0x08	; 8
 2c6:	80 93 ed 00 	sts	0x00ED, r24	; 0x8000ed <__TEXT_REGION_LENGTH__+0x7e00ed>
		data[byte] = CANMSG;
 2ca:	f8 01       	movw	r30, r16
 2cc:	e2 0f       	add	r30, r18
 2ce:	f1 1d       	adc	r31, r1
 2d0:	80 91 fa 00 	lds	r24, 0x00FA	; 0x8000fa <__TEXT_REGION_LENGTH__+0x7e00fa>
 2d4:	80 83       	st	Z, r24
		CANIDM4 = 0;
		CANCDMOB = (1 << CONMOB1) | (1 << CONMOB0)| (1<<DLC3);
		CANSTMOB = 0;
	}
	
	for(uint8_t byte = 0; byte <8; byte++){
 2d6:	2f 5f       	subi	r18, 0xFF	; 255
 2d8:	28 30       	cpi	r18, 0x08	; 8
 2da:	70 f3       	brcs	.-36     	; 0x2b8 <can_rx+0x7e>
		CANPAGE = (to_receive->mob_number << MOBNB0) | (1 << AINC) | byte;
		data[byte] = CANMSG;
	}
	
	
}
 2dc:	df 91       	pop	r29
 2de:	cf 91       	pop	r28
 2e0:	1f 91       	pop	r17
 2e2:	0f 91       	pop	r16
 2e4:	08 95       	ret

000002e6 <can_tx>:
void can_tx(struct CAN_MOB *to_send, uint8_t *data){
 2e6:	cf 93       	push	r28
 2e8:	df 93       	push	r29
 2ea:	ec 01       	movw	r28, r24
	
	for(uint8_t byte = 0; byte <8; byte++){
 2ec:	20 e0       	ldi	r18, 0x00	; 0
 2ee:	10 c0       	rjmp	.+32     	; 0x310 <can_tx+0x2a>
		CANPAGE = (to_send->mob_number << MOBNB0) | (1 << AINC) | byte;
 2f0:	8c 81       	ldd	r24, Y+4	; 0x04
 2f2:	30 e1       	ldi	r19, 0x10	; 16
 2f4:	83 9f       	mul	r24, r19
 2f6:	c0 01       	movw	r24, r0
 2f8:	11 24       	eor	r1, r1
 2fa:	82 2b       	or	r24, r18
 2fc:	88 60       	ori	r24, 0x08	; 8
 2fe:	80 93 ed 00 	sts	0x00ED, r24	; 0x8000ed <__TEXT_REGION_LENGTH__+0x7e00ed>
		CANMSG = data[byte];
 302:	fb 01       	movw	r30, r22
 304:	e2 0f       	add	r30, r18
 306:	f1 1d       	adc	r31, r1
 308:	80 81       	ld	r24, Z
 30a:	80 93 fa 00 	sts	0x00FA, r24	; 0x8000fa <__TEXT_REGION_LENGTH__+0x7e00fa>
	
	
}
void can_tx(struct CAN_MOB *to_send, uint8_t *data){
	
	for(uint8_t byte = 0; byte <8; byte++){
 30e:	2f 5f       	subi	r18, 0xFF	; 255
 310:	28 30       	cpi	r18, 0x08	; 8
 312:	70 f3       	brcs	.-36     	; 0x2f0 <can_tx+0xa>
		CANPAGE = (to_send->mob_number << MOBNB0) | (1 << AINC) | byte;
		CANMSG = data[byte];
	}
	
	CANPAGE = to_send->mob_number << MOBNB0;
 314:	8c 81       	ldd	r24, Y+4	; 0x04
 316:	82 95       	swap	r24
 318:	80 7f       	andi	r24, 0xF0	; 240
 31a:	80 93 ed 00 	sts	0x00ED, r24	; 0x8000ed <__TEXT_REGION_LENGTH__+0x7e00ed>
	if (can_check_free(to_send->mob_number)){
 31e:	8c 81       	ldd	r24, Y+4	; 0x04
 320:	30 df       	rcall	.-416    	; 0x182 <can_check_free>
 322:	88 23       	and	r24, r24
 324:	21 f1       	breq	.+72     	; 0x36e <can_tx+0x88>
		CANSTMOB = 0;
 326:	ee ee       	ldi	r30, 0xEE	; 238
 328:	f0 e0       	ldi	r31, 0x00	; 0
 32a:	10 82       	st	Z, r1
		CANIDT1 = to_send->mob_id>>3;
 32c:	88 81       	ld	r24, Y
 32e:	99 81       	ldd	r25, Y+1	; 0x01
 330:	96 95       	lsr	r25
 332:	87 95       	ror	r24
 334:	96 95       	lsr	r25
 336:	87 95       	ror	r24
 338:	96 95       	lsr	r25
 33a:	87 95       	ror	r24
 33c:	80 93 f3 00 	sts	0x00F3, r24	; 0x8000f3 <__TEXT_REGION_LENGTH__+0x7e00f3>
		CANIDT2 = (to_send->mob_id << 5) & 0b11100000;
 340:	88 81       	ld	r24, Y
 342:	82 95       	swap	r24
 344:	88 0f       	add	r24, r24
 346:	80 7e       	andi	r24, 0xE0	; 224
 348:	80 93 f2 00 	sts	0x00F2, r24	; 0x8000f2 <__TEXT_REGION_LENGTH__+0x7e00f2>
		CANIDT3 = 0;
 34c:	10 92 f1 00 	sts	0x00F1, r1	; 0x8000f1 <__TEXT_REGION_LENGTH__+0x7e00f1>
		CANIDT4 = 0;
 350:	10 92 f0 00 	sts	0x00F0, r1	; 0x8000f0 <__TEXT_REGION_LENGTH__+0x7e00f0>
		CANIDM1 = 0; //0b11111111;
 354:	10 92 f7 00 	sts	0x00F7, r1	; 0x8000f7 <__TEXT_REGION_LENGTH__+0x7e00f7>
		CANIDM2 = 0; //0b11100000;
 358:	10 92 f6 00 	sts	0x00F6, r1	; 0x8000f6 <__TEXT_REGION_LENGTH__+0x7e00f6>
		CANIDM3 = 0;
 35c:	10 92 f5 00 	sts	0x00F5, r1	; 0x8000f5 <__TEXT_REGION_LENGTH__+0x7e00f5>
		CANIDM4 = 0;
 360:	10 92 f4 00 	sts	0x00F4, r1	; 0x8000f4 <__TEXT_REGION_LENGTH__+0x7e00f4>
		CANSTMOB = 0;
 364:	10 82       	st	Z, r1
		CANCDMOB = (1<<CONMOB0) | 1 << DLC3;
 366:	88 e4       	ldi	r24, 0x48	; 72
 368:	80 93 ef 00 	sts	0x00EF, r24	; 0x8000ef <__TEXT_REGION_LENGTH__+0x7e00ef>
		CANSTMOB = 0;
 36c:	10 82       	st	Z, r1
	}
	
}
 36e:	df 91       	pop	r29
 370:	cf 91       	pop	r28
 372:	08 95       	ret

00000374 <timer1_config>:
		fan_duty = (temperature*63)/100;
	}	
}

void timer1_config(){	
DDRB |= (1<<PB6);			// setting COM1nx Bits not necessary because we can also toggle/set pins using the ISR, here the Fan PWM cable is already on the Pin toggled by those bits											
 374:	84 b1       	in	r24, 0x04	; 4
 376:	80 64       	ori	r24, 0x40	; 64
 378:	84 b9       	out	0x04, r24	; 4
TCCR1A = (1<<WGM11) | (1<<WGM10) | (0<<COM1A1) | (1<<COM1A0) | (1<<COM1B1);	//mode 15, prescaler 8, non inverted mode => page 138 - 139  
 37a:	83 e6       	ldi	r24, 0x63	; 99
 37c:	80 93 80 00 	sts	0x0080, r24	; 0x800080 <__TEXT_REGION_LENGTH__+0x7e0080>
TCCR1B = (1<<WGM13) | (1<<WGM12) | (1<<CS11);								// Fast PWM description => page 128
 380:	8a e1       	ldi	r24, 0x1A	; 26
 382:	80 93 81 00 	sts	0x0081, r24	; 0x800081 <__TEXT_REGION_LENGTH__+0x7e0081>
TIMSK1 = (1<<OCIE1A);														//Output Compare interrupt flag will be set whenever OCR1A is reached
 386:	82 e0       	ldi	r24, 0x02	; 2
 388:	80 93 6f 00 	sts	0x006F, r24	; 0x80006f <__TEXT_REGION_LENGTH__+0x7e006f>
OCR1A = 63;													// TOP  16000000/(8*(1+64)) = 30769.23077 Hz = ~30kHz => page 130   with TOP value 62+1 the resolution is 6 bit => page 128
 38c:	8f e3       	ldi	r24, 0x3F	; 63
 38e:	90 e0       	ldi	r25, 0x00	; 0
 390:	90 93 89 00 	sts	0x0089, r25	; 0x800089 <__TEXT_REGION_LENGTH__+0x7e0089>
 394:	80 93 88 00 	sts	0x0088, r24	; 0x800088 <__TEXT_REGION_LENGTH__+0x7e0088>
OCR1B = 10;                         	// BOTTOM
 398:	8a e0       	ldi	r24, 0x0A	; 10
 39a:	90 e0       	ldi	r25, 0x00	; 0
 39c:	90 93 8b 00 	sts	0x008B, r25	; 0x80008b <__TEXT_REGION_LENGTH__+0x7e008b>
 3a0:	80 93 8a 00 	sts	0x008A, r24	; 0x80008a <__TEXT_REGION_LENGTH__+0x7e008a>
 3a4:	08 95       	ret

000003a6 <__vector_12>:
}

ISR(TIMER1_COMPA_vect){									//ISR for the timer 1, updating the duty cycle
 3a6:	1f 92       	push	r1
 3a8:	0f 92       	push	r0
 3aa:	0f b6       	in	r0, 0x3f	; 63
 3ac:	0f 92       	push	r0
 3ae:	11 24       	eor	r1, r1
 3b0:	8f 93       	push	r24
 3b2:	9f 93       	push	r25
//cli();
OCR1B = fan_duty;
 3b4:	80 91 2a 01 	lds	r24, 0x012A	; 0x80012a <fan_duty>
 3b8:	90 e0       	ldi	r25, 0x00	; 0
 3ba:	90 93 8b 00 	sts	0x008B, r25	; 0x80008b <__TEXT_REGION_LENGTH__+0x7e008b>
 3be:	80 93 8a 00 	sts	0x008A, r24	; 0x80008a <__TEXT_REGION_LENGTH__+0x7e008a>
//sei();
 3c2:	9f 91       	pop	r25
 3c4:	8f 91       	pop	r24
 3c6:	0f 90       	pop	r0
 3c8:	0f be       	out	0x3f, r0	; 63
 3ca:	0f 90       	pop	r0
 3cc:	1f 90       	pop	r1
 3ce:	18 95       	reti

000003d0 <main>:
volatile uint8_t x = 0;

extern volatile uint8_t fan_duty;
uint8_t R2D_pressed = 0;

int main(void){
 3d0:	cf 93       	push	r28
 3d2:	df 93       	push	r29
 3d4:	cd b7       	in	r28, 0x3d	; 61
 3d6:	de b7       	in	r29, 0x3e	; 62
 3d8:	c1 54       	subi	r28, 0x41	; 65
 3da:	d1 09       	sbc	r29, r1
 3dc:	0f b6       	in	r0, 0x3f	; 63
 3de:	f8 94       	cli
 3e0:	de bf       	out	0x3e, r29	; 62
 3e2:	0f be       	out	0x3f, r0	; 63
 3e4:	cd bf       	out	0x3d, r28	; 61

sys_timer_config();
 3e6:	7c d1       	rcall	.+760    	; 0x6e0 <sys_timer_config>
port_config();
 3e8:	72 d1       	rcall	.+740    	; 0x6ce <port_config>
can_cfg();
 3ea:	e8 de       	rcall	.-560    	; 0x1bc <can_cfg>
adc_config();
 3ec:	71 de       	rcall	.-798    	; 0xd0 <adc_config>
 3ee:	b8 d1       	rcall	.+880    	; 0x760 <timer2_config>
timer2_config();
 3f0:	c1 df       	rcall	.-126    	; 0x374 <timer1_config>
 3f2:	83 ed       	ldi	r24, 0xD3	; 211
timer1_config();
 3f4:	90 e3       	ldi	r25, 0x30	; 48
 3f6:	01 97       	sbiw	r24, 0x01	; 1
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 3f8:	f1 f7       	brne	.-4      	; 0x3f6 <main+0x26>
 3fa:	00 c0       	rjmp	.+0      	; 0x3fc <main+0x2c>
 3fc:	00 00       	nop
 3fe:	1c 82       	std	Y+4, r1	; 0x04
 400:	1b 82       	std	Y+3, r1	; 0x03
 402:	81 e0       	ldi	r24, 0x01	; 1
//fan only works for 50 ms delay between arming and cfg (look up the requirements later
//i pretty much got this 50ms though trial and error

struct CAN_MOB can_Fusebox0_mob;
can_Fusebox0_mob.mob_id = 0x600;
can_Fusebox0_mob.mob_idmask = 0; //sent
 404:	96 e0       	ldi	r25, 0x06	; 6
 406:	9a 83       	std	Y+2, r25	; 0x02
can_Fusebox0_mob.mob_number = 1;
uint8_t Fusebox0_databytes[8];

struct CAN_MOB can_Fusebox1_mob;
can_Fusebox0_mob.mob_id = 0x601;
 408:	89 83       	std	Y+1, r24	; 0x01
 40a:	82 e0       	ldi	r24, 0x02	; 2
 40c:	8d 83       	std	Y+5, r24	; 0x05
 40e:	80 e0       	ldi	r24, 0x00	; 0
can_Fusebox0_mob.mob_idmask = 0; //sent
can_Fusebox0_mob.mob_number = 2;
 410:	94 e0       	ldi	r25, 0x04	; 4
 412:	9c 8f       	std	Y+28, r25	; 0x1c
uint8_t Fusebox1_databytes[8];


struct CAN_MOB can_SHR0_mob;
can_SHR0_mob.mob_id = 0x400;
 414:	8b 8f       	std	Y+27, r24	; 0x1b
 416:	8f ef       	ldi	r24, 0xFF	; 255
 418:	97 e0       	ldi	r25, 0x07	; 7
 41a:	9e 8f       	std	Y+30, r25	; 0x1e
can_SHR0_mob.mob_idmask = 0b11111111111; //receive with no filer?
 41c:	8d 8f       	std	Y+29, r24	; 0x1d
 41e:	23 e0       	ldi	r18, 0x03	; 3
 420:	2f 8f       	std	Y+31, r18	; 0x1f
 422:	20 e2       	ldi	r18, 0x20	; 32
can_SHR0_mob.mob_number = 3;  //IDs might be wrong
 424:	34 e0       	ldi	r19, 0x04	; 4
 426:	39 a7       	std	Y+41, r19	; 0x29
uint8_t SHR0_databytes[8];

struct CAN_MOB can_SHB0_mob;
can_SHB0_mob.mob_id = 0x420;
 428:	28 a7       	std	Y+40, r18	; 0x28
 42a:	9b a7       	std	Y+43, r25	; 0x2b
 42c:	8a a7       	std	Y+42, r24	; 0x2a
 42e:	85 e0       	ldi	r24, 0x05	; 5
can_SHB0_mob.mob_idmask = 0b11111111111; //receive with no filter?
 430:	8c a7       	std	Y+44, r24	; 0x2c
 432:	80 e0       	ldi	r24, 0x00	; 0
can_SHB0_mob.mob_number = 5;
 434:	95 e0       	ldi	r25, 0x05	; 5
 436:	9e ab       	std	Y+54, r25	; 0x36
uint8_t SHB0_databytes[8];

struct CAN_MOB can_DIC0_mob;	
can_DIC0_mob.mob_id = 0x500;
 438:	8d ab       	std	Y+53, r24	; 0x35
 43a:	8f ef       	ldi	r24, 0xFF	; 255
 43c:	9f ef       	ldi	r25, 0xFF	; 255
 43e:	98 af       	std	Y+56, r25	; 0x38
can_DIC0_mob.mob_idmask = 0xffff;
 440:	8f ab       	std	Y+55, r24	; 0x37
 442:	8b e0       	ldi	r24, 0x0B	; 11
 444:	89 af       	std	Y+57, r24	; 0x39
 446:	78 94       	sei
can_DIC0_mob.mob_number = 11;
 448:	13 c0       	rjmp	.+38     	; 0x470 <__LOCK_REGION_LENGTH__+0x70>
 44a:	88 3e       	cpi	r24, 0xE8	; 232
uint8_t DIC0_databytes[8];

//timer1_config();
sei();
 44c:	93 40       	sbci	r25, 0x03	; 3
// 		}//end of if containing the decrementing condition = 1
// 	} //end first 3s of arming seq (while)
		
	//} //end of 6s arming seq
	
	while (sys_time < 2000){
 44e:	a1 05       	cpc	r26, r1
// 		if (sys_time == 5000){
// 			increment_flag = 2;
// 		}
		if (sys_time == 1000){
 450:	b1 05       	cpc	r27, r1
 452:	19 f4       	brne	.+6      	; 0x45a <__LOCK_REGION_LENGTH__+0x5a>
 454:	81 e0       	ldi	r24, 0x01	; 1
 456:	80 93 0b 01 	sts	0x010B, r24	; 0x80010b <increment_flag>
			increment_flag = 1;
 45a:	80 91 0b 01 	lds	r24, 0x010B	; 0x80010b <increment_flag>
 45e:	81 11       	cpse	r24, r1
		}
		if(increment_flag == 0){
 460:	03 c0       	rjmp	.+6      	; 0x468 <__LOCK_REGION_LENGTH__+0x68>
 462:	94 e1       	ldi	r25, 0x14	; 20
 464:	90 93 2a 01 	sts	0x012A, r25	; 0x80012a <fan_duty>
			fan_duty = 20;
 468:	81 30       	cpi	r24, 0x01	; 1
 46a:	11 f4       	brne	.+4      	; 0x470 <__LOCK_REGION_LENGTH__+0x70>
 46c:	10 92 2a 01 	sts	0x012A, r1	; 0x80012a <fan_duty>
		} //end of if containing the incrementing condition = 0
		if (increment_flag == 1){	
 470:	80 91 1c 01 	lds	r24, 0x011C	; 0x80011c <sys_time>
			fan_duty = 0;
 474:	90 91 1d 01 	lds	r25, 0x011D	; 0x80011d <sys_time+0x1>
// 		}//end of if containing the decrementing condition = 1
// 	} //end first 3s of arming seq (while)
		
	//} //end of 6s arming seq
	
	while (sys_time < 2000){
 478:	a0 91 1e 01 	lds	r26, 0x011E	; 0x80011e <sys_time+0x2>
 47c:	b0 91 1f 01 	lds	r27, 0x011F	; 0x80011f <sys_time+0x3>
 480:	80 3d       	cpi	r24, 0xD0	; 208
 482:	17 e0       	ldi	r17, 0x07	; 7
 484:	91 07       	cpc	r25, r17
 486:	a1 05       	cpc	r26, r1
 488:	b1 05       	cpc	r27, r1
 48a:	f8 f2       	brcs	.-66     	; 0x44a <__LOCK_REGION_LENGTH__+0x4a>
 48c:	80 91 1c 01 	lds	r24, 0x011C	; 0x80011c <sys_time>
 490:	90 91 1d 01 	lds	r25, 0x011D	; 0x80011d <sys_time+0x1>
// 		}
	} //end first XXXms of arming seq (while)
	
	
	while (1){
		if(TIME_PASSED_10_MS){			// (sys_time - time_old) > 10
 494:	a0 91 1e 01 	lds	r26, 0x011E	; 0x80011e <sys_time+0x2>
 498:	b0 91 1f 01 	lds	r27, 0x011F	; 0x80011f <sys_time+0x3>
 49c:	40 91 18 01 	lds	r20, 0x0118	; 0x800118 <time_old>
 4a0:	50 91 19 01 	lds	r21, 0x0119	; 0x800119 <time_old+0x1>
 4a4:	60 91 1a 01 	lds	r22, 0x011A	; 0x80011a <time_old+0x2>
 4a8:	70 91 1b 01 	lds	r23, 0x011B	; 0x80011b <time_old+0x3>
 4ac:	8c 01       	movw	r16, r24
 4ae:	9d 01       	movw	r18, r26
 4b0:	04 1b       	sub	r16, r20
 4b2:	15 0b       	sbc	r17, r21
 4b4:	26 0b       	sbc	r18, r22
 4b6:	37 0b       	sbc	r19, r23
 4b8:	0b 30       	cpi	r16, 0x0B	; 11
 4ba:	11 05       	cpc	r17, r1
 4bc:	21 05       	cpc	r18, r1
 4be:	31 05       	cpc	r19, r1
 4c0:	08 f4       	brcc	.+2      	; 0x4c4 <__LOCK_REGION_LENGTH__+0xc4>
 4c2:	c2 c0       	rjmp	.+388    	; 0x648 <__LOCK_REGION_LENGTH__+0x248>
 4c4:	80 93 18 01 	sts	0x0118, r24	; 0x800118 <time_old>
 4c8:	90 93 19 01 	sts	0x0119, r25	; 0x800119 <time_old+0x1>
			time_old = sys_time; 
 4cc:	a0 93 1a 01 	sts	0x011A, r26	; 0x80011a <time_old+0x2>
 4d0:	b0 93 1b 01 	sts	0x011B, r27	; 0x80011b <time_old+0x3>
 4d4:	80 91 14 01 	lds	r24, 0x0114	; 0x800114 <time_old_100ms>
 4d8:	90 91 15 01 	lds	r25, 0x0115	; 0x800115 <time_old_100ms+0x1>
			time_old_100ms++;   //FIND BETTER NAME, WHY OLD??
 4dc:	a0 91 16 01 	lds	r26, 0x0116	; 0x800116 <time_old_100ms+0x2>
 4e0:	b0 91 17 01 	lds	r27, 0x0117	; 0x800117 <time_old_100ms+0x3>
 4e4:	01 96       	adiw	r24, 0x01	; 1
 4e6:	a1 1d       	adc	r26, r1
 4e8:	b1 1d       	adc	r27, r1
 4ea:	80 93 14 01 	sts	0x0114, r24	; 0x800114 <time_old_100ms>
 4ee:	90 93 15 01 	sts	0x0115, r25	; 0x800115 <time_old_100ms+0x1>
 4f2:	a0 93 16 01 	sts	0x0116, r26	; 0x800116 <time_old_100ms+0x2>
 4f6:	b0 93 17 01 	sts	0x0117, r27	; 0x800117 <time_old_100ms+0x3>
 4fa:	80 91 10 01 	lds	r24, 0x0110	; 0x800110 <time_200ms>
 4fe:	90 91 11 01 	lds	r25, 0x0111	; 0x800111 <time_200ms+0x1>
			time_200ms++;
 502:	a0 91 12 01 	lds	r26, 0x0112	; 0x800112 <time_200ms+0x2>
 506:	b0 91 13 01 	lds	r27, 0x0113	; 0x800113 <time_200ms+0x3>
 50a:	01 96       	adiw	r24, 0x01	; 1
 50c:	a1 1d       	adc	r26, r1
 50e:	b1 1d       	adc	r27, r1
 510:	80 93 10 01 	sts	0x0110, r24	; 0x800110 <time_200ms>
 514:	90 93 11 01 	sts	0x0111, r25	; 0x800111 <time_200ms+0x1>
 518:	a0 93 12 01 	sts	0x0112, r26	; 0x800112 <time_200ms+0x2>
 51c:	b0 93 13 01 	sts	0x0113, r27	; 0x800113 <time_200ms+0x3>
 520:	80 91 0c 01 	lds	r24, 0x010C	; 0x80010c <test_timer1>
 524:	90 91 0d 01 	lds	r25, 0x010D	; 0x80010d <test_timer1+0x1>
			test_timer1++;
 528:	a0 91 0e 01 	lds	r26, 0x010E	; 0x80010e <test_timer1+0x2>
 52c:	b0 91 0f 01 	lds	r27, 0x010F	; 0x80010f <test_timer1+0x3>
 530:	01 96       	adiw	r24, 0x01	; 1
 532:	a1 1d       	adc	r26, r1
 534:	b1 1d       	adc	r27, r1
 536:	80 93 0c 01 	sts	0x010C, r24	; 0x80010c <test_timer1>
 53a:	90 93 0d 01 	sts	0x010D, r25	; 0x80010d <test_timer1+0x1>
 53e:	a0 93 0e 01 	sts	0x010E, r26	; 0x80010e <test_timer1+0x2>
 542:	b0 93 0f 01 	sts	0x010F, r27	; 0x80010f <test_timer1+0x3>
 546:	2c b1       	in	r18, 0x0c	; 12
 548:	80 b1       	in	r24, 0x00	; 0
 54a:	90 e0       	ldi	r25, 0x00	; 0
			
			if (FUSES_ALL_IN){	
 54c:	98 2f       	mov	r25, r24
 54e:	88 27       	eor	r24, r24
 550:	9f 70       	andi	r25, 0x0F	; 15
 552:	82 2b       	or	r24, r18
 554:	8f 3f       	cpi	r24, 0xFF	; 255
 556:	9f 40       	sbci	r25, 0x0F	; 15
 558:	11 f4       	brne	.+4      	; 0x55e <__LOCK_REGION_LENGTH__+0x15e>
 55a:	fa d0       	rcall	.+500    	; 0x750 <fault_not_detected>
				fault_not_detected();																					
 55c:	01 c0       	rjmp	.+2      	; 0x560 <__LOCK_REGION_LENGTH__+0x160>
 55e:	fc d0       	rcall	.+504    	; 0x758 <fault_detected>
			}																															
			else{
				fault_detected();	
 560:	80 e0       	ldi	r24, 0x00	; 0
			} 
	//MOVE THESE NOTES TO THE MAIN DESCRIPTION THAT WILL COME ON TOP OF THE C FILE JUST LIKE IN THE FAN POWER UNIT 					
//fuse_read_out()&0xff;			// input &0xff gives you the first byte (8bit) (least significant byte)  
//(fuse_read_out()>>8)&0xff;		//shifting 1 byte to the right gives us the next 8 bit bundle, now we've read the full 16 bit value

 			Fusebox0_databytes[0]	=	adc_get(0)&0xff			;
 562:	06 de       	rcall	.-1012   	; 0x170 <adc_get>
 564:	8e 83       	std	Y+6, r24	; 0x06
 566:	80 e0       	ldi	r24, 0x00	; 0
			Fusebox0_databytes[1]	=	(adc_get(0)>>8)&0xff	;	
 568:	03 de       	rcall	.-1018   	; 0x170 <adc_get>
 56a:	9f 83       	std	Y+7, r25	; 0x07
 56c:	81 e0       	ldi	r24, 0x01	; 1
 56e:	00 de       	rcall	.-1024   	; 0x170 <adc_get>
 			Fusebox0_databytes[2]	=	adc_get(1)&0xff			;	
 570:	88 87       	std	Y+8, r24	; 0x08
 572:	81 e0       	ldi	r24, 0x01	; 1
 574:	fd dd       	rcall	.-1030   	; 0x170 <adc_get>
 576:	99 87       	std	Y+9, r25	; 0x09
 			Fusebox0_databytes[3]	=	(adc_get(1)>>8)&0xff	; 
 578:	1a 86       	std	Y+10, r1	; 0x0a
 57a:	1b 86       	std	Y+11, r1	; 0x0b
 57c:	1c 86       	std	Y+12, r1	; 0x0c
			Fusebox0_databytes[4]	=	0						;
 57e:	1d 86       	std	Y+13, r1	; 0x0d
			Fusebox0_databytes[5]	=	0						;
 580:	be 01       	movw	r22, r28
 			Fusebox0_databytes[6]	=	0						;
 582:	6a 5f       	subi	r22, 0xFA	; 250
			Fusebox0_databytes[7]	=	0						;
			
			
			
 			
			can_tx(&can_Fusebox0_mob, Fusebox0_databytes); 
 584:	7f 4f       	sbci	r23, 0xFF	; 255
 586:	ce 01       	movw	r24, r28
 588:	01 96       	adiw	r24, 0x01	; 1
 58a:	ad de       	rcall	.-678    	; 0x2e6 <can_tx>
 58c:	be 01       	movw	r22, r28
 58e:	63 5d       	subi	r22, 0xD3	; 211
			 
			//can_rx(&can_R2D_mob, R2D_databytes);
			can_rx(&can_SHB0_mob, SHB0_databytes);
 590:	7f 4f       	sbci	r23, 0xFF	; 255
 592:	ce 01       	movw	r24, r28
 594:	88 96       	adiw	r24, 0x28	; 40
 596:	51 de       	rcall	.-862    	; 0x23a <can_rx>
 598:	be 01       	movw	r22, r28
 59a:	60 5e       	subi	r22, 0xE0	; 224
			can_rx(&can_SHR0_mob, SHR0_databytes); //recieve at same freq as sender right?
 59c:	7f 4f       	sbci	r23, 0xFF	; 255
 59e:	ce 01       	movw	r24, r28
 5a0:	4b 96       	adiw	r24, 0x1b	; 27
 5a2:	4b de       	rcall	.-874    	; 0x23a <can_rx>
 5a4:	be 01       	movw	r22, r28
 5a6:	66 5c       	subi	r22, 0xC6	; 198
 5a8:	7f 4f       	sbci	r23, 0xFF	; 255
			can_rx(&can_DIC0_mob, DIC0_databytes);
 5aa:	ce 01       	movw	r24, r28
 5ac:	c5 96       	adiw	r24, 0x35	; 53
 5ae:	45 de       	rcall	.-886    	; 0x23a <can_rx>
 5b0:	2c b1       	in	r18, 0x0c	; 12
 5b2:	80 b1       	in	r24, 0x00	; 0
 5b4:	90 e0       	ldi	r25, 0x00	; 0
 5b6:	98 2f       	mov	r25, r24
			
		//	R2D_pressed = R2D_databytes[2];
											// define CAR_IS_READY_TO_DRIVE [combines the 3 conditions]
			if ((fuse_read_out() & 0xFFF) < 0xFFF){  //debugging purposes fuse acts as my switch, NO MACRO NOW THE 3 CONDITIONS COME HERE: READY TO DRIVE, POWER ON and BUTTON PRESSED?
 5b8:	88 27       	eor	r24, r24
 5ba:	9f 70       	andi	r25, 0x0F	; 15
 5bc:	82 2b       	or	r24, r18
 5be:	8f 3f       	cpi	r24, 0xFF	; 255
 5c0:	9f 40       	sbci	r25, 0x0F	; 15
 5c2:	28 f4       	brcc	.+10     	; 0x5ce <__LOCK_REGION_LENGTH__+0x1ce>
 5c4:	e0 eb       	ldi	r30, 0xB0	; 176
 5c6:	f0 e0       	ldi	r31, 0x00	; 0
 5c8:	80 81       	ld	r24, Z
 5ca:	84 60       	ori	r24, 0x04	; 4
 					START_TIMER_2; 				
 5cc:	80 83       	st	Z, r24
 5ce:	80 91 22 01 	lds	r24, 0x0122	; 0x800122 <r2d_length>
 5d2:	90 91 23 01 	lds	r25, 0x0123	; 0x800123 <r2d_length+0x1>
			}  

				//define SOUND_STILL_GOING? r2dl < xxx  // <= make that macro and a function that caclulates the time or soemthing, input time in seconds (1-3s) and it will calculate the value for the condition 2,5 seconds = 23000 or something (need to measure it better)
			if (r2d_length < 23000/*<noise_length (change r2dlength to something like r2d_ticks*/){ // under 3 seconds (tested with a stopwatch) as long as the button is not held longer than a singular press => will lead into a 2nd cycle starting 
 5d6:	a0 91 24 01 	lds	r26, 0x0124	; 0x800124 <r2d_length+0x2>
 5da:	b0 91 25 01 	lds	r27, 0x0125	; 0x800125 <r2d_length+0x3>
 5de:	88 3d       	cpi	r24, 0xD8	; 216
 5e0:	99 45       	sbci	r25, 0x59	; 89
 5e2:	a1 05       	cpc	r26, r1
 5e4:	b1 05       	cpc	r27, r1
 5e6:	a0 f4       	brcc	.+40     	; 0x610 <__LOCK_REGION_LENGTH__+0x210>
 5e8:	80 91 21 01 	lds	r24, 0x0121	; 0x800121 <note_length>
 5ec:	8f 5f       	subi	r24, 0xFF	; 255
 5ee:	80 93 21 01 	sts	0x0121, r24	; 0x800121 <note_length>
									
				note_length++;
 5f2:	85 30       	cpi	r24, 0x05	; 5
 5f4:	39 f4       	brne	.+14     	; 0x604 <__LOCK_REGION_LENGTH__+0x204>
 5f6:	10 92 21 01 	sts	0x0121, r1	; 0x800121 <note_length>

 				if (note_length == 5){
 5fa:	80 91 20 01 	lds	r24, 0x0120	; 0x800120 <note_next>
				note_length = 0;
 5fe:	8f 5f       	subi	r24, 0xFF	; 255
 600:	80 93 20 01 	sts	0x0120, r24	; 0x800120 <note_next>
 				note_next++;
 604:	80 91 20 01 	lds	r24, 0x0120	; 0x800120 <note_next>
 608:	8a 30       	cpi	r24, 0x0A	; 10
 60a:	11 f4       	brne	.+4      	; 0x610 <__LOCK_REGION_LENGTH__+0x210>
				}
 				if (note_next == 10){
 60c:	10 92 20 01 	sts	0x0120, r1	; 0x800120 <note_next>
 610:	80 91 22 01 	lds	r24, 0x0122	; 0x800122 <r2d_length>
 				note_next = 0;
 614:	90 91 23 01 	lds	r25, 0x0123	; 0x800123 <r2d_length+0x1>
 				}	
			}	
			if (r2d_length >= 23000){   //turn into an else{}
 618:	a0 91 24 01 	lds	r26, 0x0124	; 0x800124 <r2d_length+0x2>
 61c:	b0 91 25 01 	lds	r27, 0x0125	; 0x800125 <r2d_length+0x3>
 620:	88 3d       	cpi	r24, 0xD8	; 216
 622:	99 45       	sbci	r25, 0x59	; 89
 624:	a1 05       	cpc	r26, r1
 626:	b1 05       	cpc	r27, r1
 628:	78 f0       	brcs	.+30     	; 0x648 <__LOCK_REGION_LENGTH__+0x248>
 62a:	e0 eb       	ldi	r30, 0xB0	; 176
 62c:	f0 e0       	ldi	r31, 0x00	; 0
 62e:	80 81       	ld	r24, Z
 630:	8b 7f       	andi	r24, 0xFB	; 251
				TCCR2A &= ~(1<<CS22);
 632:	80 83       	st	Z, r24
 634:	10 92 22 01 	sts	0x0122, r1	; 0x800122 <r2d_length>
 638:	10 92 23 01 	sts	0x0123, r1	; 0x800123 <r2d_length+0x1>
				r2d_length = 0;
 63c:	10 92 24 01 	sts	0x0124, r1	; 0x800124 <r2d_length+0x2>
 640:	10 92 25 01 	sts	0x0125, r1	; 0x800125 <r2d_length+0x3>
 644:	10 92 20 01 	sts	0x0120, r1	; 0x800120 <note_next>
 648:	80 91 14 01 	lds	r24, 0x0114	; 0x800114 <time_old_100ms>
				note_next = 0;
 64c:	90 91 15 01 	lds	r25, 0x0115	; 0x800115 <time_old_100ms+0x1>
			}
	
		}	//end of 10 ms cycle
	
		if (/*time_old_100ms >= 100*/TIME_PASSED_100_MS){ //100 ms
 650:	a0 91 16 01 	lds	r26, 0x0116	; 0x800116 <time_old_100ms+0x2>
 654:	b0 91 17 01 	lds	r27, 0x0117	; 0x800117 <time_old_100ms+0x3>
 658:	84 36       	cpi	r24, 0x64	; 100
 65a:	91 05       	cpc	r25, r1
 65c:	a1 05       	cpc	r26, r1
 65e:	b1 05       	cpc	r27, r1
 660:	60 f0       	brcs	.+24     	; 0x67a <__LOCK_REGION_LENGTH__+0x27a>
 662:	10 92 14 01 	sts	0x0114, r1	; 0x800114 <time_old_100ms>
 666:	10 92 15 01 	sts	0x0115, r1	; 0x800115 <time_old_100ms+0x1>
 			time_old_100ms = 0;
 66a:	10 92 16 01 	sts	0x0116, r1	; 0x800116 <time_old_100ms+0x2>
 66e:	10 92 17 01 	sts	0x0117, r1	; 0x800117 <time_old_100ms+0x3>
 672:	44 d0       	rcall	.+136    	; 0x6fc <sys_tick_heart>
 674:	8f e0       	ldi	r24, 0x0F	; 15
 676:	80 93 2a 01 	sts	0x012A, r24	; 0x80012a <fan_duty>
 			sys_tick_heart();  //remove the sys_, tick_heart obvious by itself
 67a:	80 91 10 01 	lds	r24, 0x0110	; 0x800110 <time_200ms>
			// for (int8_t x = 5; x < 40; x++){  //testing the range of values to alter the duty%
 				//int16_t CAN_temperature = x; //from can
 				uint8_t temperature = x;//(uint8_t) CAN_temperature;
 			//	_delay_ms(8);   //use sys timer later
 			//	fan_power_unit_PWM_control(temperature, fan_duty); 	
			 fan_duty = (temperature*63)/100;
 67e:	90 91 11 01 	lds	r25, 0x0111	; 0x800111 <time_200ms+0x1>
 			//} //end of for
		
			// }
			 
 		}  //end of 100ms
		if (time_200ms >= 20){
 682:	a0 91 12 01 	lds	r26, 0x0112	; 0x800112 <time_200ms+0x2>
 686:	b0 91 13 01 	lds	r27, 0x0113	; 0x800113 <time_200ms+0x3>
 68a:	44 97       	sbiw	r24, 0x14	; 20
 68c:	a1 05       	cpc	r26, r1
 68e:	b1 05       	cpc	r27, r1
 690:	08 f4       	brcc	.+2      	; 0x694 <__LOCK_REGION_LENGTH__+0x294>
 692:	fc ce       	rjmp	.-520    	; 0x48c <__LOCK_REGION_LENGTH__+0x8c>
 694:	10 92 10 01 	sts	0x0110, r1	; 0x800110 <time_200ms>
 698:	10 92 11 01 	sts	0x0111, r1	; 0x800111 <time_200ms+0x1>
			time_200ms = 0;
 69c:	10 92 12 01 	sts	0x0112, r1	; 0x800112 <time_200ms+0x2>
 6a0:	10 92 13 01 	sts	0x0113, r1	; 0x800113 <time_200ms+0x3>
 6a4:	86 b1       	in	r24, 0x06	; 6
 6a6:	8b 8b       	std	Y+19, r24	; 0x13
 6a8:	1c 8a       	std	Y+20, r1	; 0x14
 6aa:	80 b1       	in	r24, 0x00	; 0
			
			Fusebox1_databytes[0]	=	SCI_read_out()			;
 6ac:	8c b1       	in	r24, 0x0c	; 12
 6ae:	8d 8b       	std	Y+21, r24	; 0x15
			Fusebox1_databytes[1]	= 0;
			Fusebox1_databytes[2]	=	fuse_read_out()&0xff		;
 6b0:	9c b1       	in	r25, 0x0c	; 12
 6b2:	80 b1       	in	r24, 0x00	; 0
 6b4:	89 2b       	or	r24, r25
			Fusebox1_databytes[3]	=	(fuse_read_out()>>8)&0xff	;
 6b6:	8e 8b       	std	Y+22, r24	; 0x16
 6b8:	1f 8a       	std	Y+23, r1	; 0x17
 6ba:	18 8e       	std	Y+24, r1	; 0x18
 6bc:	19 8e       	std	Y+25, r1	; 0x19
			Fusebox1_databytes[4]	= 0;
 6be:	1a 8e       	std	Y+26, r1	; 0x1a
			Fusebox1_databytes[5]	= 0;
 6c0:	be 01       	movw	r22, r28
			Fusebox1_databytes[6]	= 0;
 6c2:	6d 5e       	subi	r22, 0xED	; 237
			Fusebox1_databytes[7]	= 0;
 6c4:	7f 4f       	sbci	r23, 0xFF	; 255
			
			can_tx(&can_Fusebox1_mob, Fusebox1_databytes);
 6c6:	ce 01       	movw	r24, r28
 6c8:	0e 96       	adiw	r24, 0x0e	; 14
 6ca:	0d de       	rcall	.-998    	; 0x2e6 <can_tx>
 6cc:	df ce       	rjmp	.-578    	; 0x48c <__LOCK_REGION_LENGTH__+0x8c>

000006ce <port_config>:
#include <avr/interrupt.h>

volatile unsigned long sys_time = 0;

void port_config(){  //0 input, 1 output
	DDRA = 0;   //Fuse Read Out Inputs
 6ce:	11 b8       	out	0x01, r1	; 1
	DDRB = 0 | (1<<PB0) |(1<<PB2) | (1<<PB3) | (1<<PB4) | (1<<PB5); //WP, fan and LED outputs
 6d0:	8d e3       	ldi	r24, 0x3D	; 61
 6d2:	84 b9       	out	0x04, r24	; 4
	DDRC = 0; // Shutdown circuit just like FRO is an input 
 6d4:	17 b8       	out	0x07, r1	; 7
	DDRD = 0 | (1<<PD2) | (1<<PD3) | (1<<PD5); /*| (1<<PD6);SET TO 0?*/ // timer for the buzzer and can outputs, PD5 transmits to CAN, PD6 is a receiver
 6d6:	8c e2       	ldi	r24, 0x2C	; 44
 6d8:	8a b9       	out	0x0a, r24	; 10
	DDRE = 0; //Fuse Read Out Inputs
 6da:	1d b8       	out	0x0d, r1	; 13
	DDRF = 0; //JTAG and 2 ADC readings inputs
 6dc:	10 ba       	out	0x10, r1	; 16
 6de:	08 95       	ret

000006e0 <sys_timer_config>:
}

void sys_timer_config(){  
	TCCR0A |= (1<<WGM01); //CTC mode
 6e0:	84 b5       	in	r24, 0x24	; 36
 6e2:	88 60       	ori	r24, 0x08	; 8
 6e4:	84 bd       	out	0x24, r24	; 36
	TCCR0A |= (1<<CS01) | (1<<CS00); //prescaler 64 => page 111
 6e6:	84 b5       	in	r24, 0x24	; 36
 6e8:	83 60       	ori	r24, 0x03	; 3
 6ea:	84 bd       	out	0x24, r24	; 36
	TIMSK0 |= (1<<OCF0A);  //interrupt flags enable
 6ec:	ee e6       	ldi	r30, 0x6E	; 110
 6ee:	f0 e0       	ldi	r31, 0x00	; 0
 6f0:	80 81       	ld	r24, Z
 6f2:	82 60       	ori	r24, 0x02	; 2
 6f4:	80 83       	st	Z, r24
	OCR0A = 124;  //TOP for 1ms   => 16000000/2*64*(1+124) = 1000 Hz
 6f6:	8c e7       	ldi	r24, 0x7C	; 124
 6f8:	87 bd       	out	0x27, r24	; 39
 6fa:	08 95       	ret

000006fc <sys_tick_heart>:
}

void sys_tick_heart(){
	PORTB ^= (1<<PB4); //toggle the Heart led on Pin 4, will be used in the super loop in main.c to indicade that the loop is running correctly	
 6fc:	95 b1       	in	r25, 0x05	; 5
 6fe:	80 e1       	ldi	r24, 0x10	; 16
 700:	89 27       	eor	r24, r25
 702:	85 b9       	out	0x05, r24	; 5
 704:	08 95       	ret

00000706 <__vector_16>:
};

ISR(TIMER0_COMP_vect){
 706:	1f 92       	push	r1
 708:	0f 92       	push	r0
 70a:	0f b6       	in	r0, 0x3f	; 63
 70c:	0f 92       	push	r0
 70e:	11 24       	eor	r1, r1
 710:	8f 93       	push	r24
 712:	9f 93       	push	r25
 714:	af 93       	push	r26
 716:	bf 93       	push	r27
//	cli();
	sys_time++;  //system time incremented on each interrupt flag from the CTC mode compare register => every OCR0A
 718:	80 91 1c 01 	lds	r24, 0x011C	; 0x80011c <sys_time>
 71c:	90 91 1d 01 	lds	r25, 0x011D	; 0x80011d <sys_time+0x1>
 720:	a0 91 1e 01 	lds	r26, 0x011E	; 0x80011e <sys_time+0x2>
 724:	b0 91 1f 01 	lds	r27, 0x011F	; 0x80011f <sys_time+0x3>
 728:	01 96       	adiw	r24, 0x01	; 1
 72a:	a1 1d       	adc	r26, r1
 72c:	b1 1d       	adc	r27, r1
 72e:	80 93 1c 01 	sts	0x011C, r24	; 0x80011c <sys_time>
 732:	90 93 1d 01 	sts	0x011D, r25	; 0x80011d <sys_time+0x1>
 736:	a0 93 1e 01 	sts	0x011E, r26	; 0x80011e <sys_time+0x2>
 73a:	b0 93 1f 01 	sts	0x011F, r27	; 0x80011f <sys_time+0x3>
	//sei();
}
 73e:	bf 91       	pop	r27
 740:	af 91       	pop	r26
 742:	9f 91       	pop	r25
 744:	8f 91       	pop	r24
 746:	0f 90       	pop	r0
 748:	0f be       	out	0x3f, r0	; 63
 74a:	0f 90       	pop	r0
 74c:	1f 90       	pop	r1
 74e:	18 95       	reti

00000750 <fault_not_detected>:

void fault_not_detected(){	
	PORTB &= ~(1<<PB3); //turn off red led in case of no fault
 750:	85 b1       	in	r24, 0x05	; 5
 752:	87 7f       	andi	r24, 0xF7	; 247
 754:	85 b9       	out	0x05, r24	; 5
 756:	08 95       	ret

00000758 <fault_detected>:
}
void fault_detected(){
	PORTB |= (1<<PB3); //turn on red led when called (fault present)
 758:	85 b1       	in	r24, 0x05	; 5
 75a:	88 60       	ori	r24, 0x08	; 8
 75c:	85 b9       	out	0x05, r24	; 5
 75e:	08 95       	ret

00000760 <timer2_config>:
		if (note_length == 5){
			note_length = 0;
			note_next++;
		}
		if (note_next == 10){
			note_next = 0;
 760:	e0 eb       	ldi	r30, 0xB0	; 176
 762:	f0 e0       	ldi	r31, 0x00	; 0
 764:	80 81       	ld	r24, Z
 766:	88 60       	ori	r24, 0x08	; 8
 768:	80 83       	st	Z, r24
 76a:	82 e0       	ldi	r24, 0x02	; 2
 76c:	80 93 70 00 	sts	0x0070, r24	; 0x800070 <__TEXT_REGION_LENGTH__+0x7e0070>
 770:	08 95       	ret

00000772 <__vector_9>:
		}
}

ISR(TIMER2_COMP_vect){ //isr for timer2 
 772:	1f 92       	push	r1
 774:	0f 92       	push	r0
 776:	0f b6       	in	r0, 0x3f	; 63
 778:	0f 92       	push	r0
 77a:	11 24       	eor	r1, r1
 77c:	0b b6       	in	r0, 0x3b	; 59
 77e:	0f 92       	push	r0
 780:	8f 93       	push	r24
 782:	9f 93       	push	r25
 784:	af 93       	push	r26
 786:	bf 93       	push	r27
 788:	ef 93       	push	r30
 78a:	ff 93       	push	r31
	//cli(); // if cli() and sei() at the end are deployed, the code slows down immensly (longer sounds etc, but the overall r2d length does not get affected at all since its inside the ISR)
	PORTD ^= (1<<PD2);
 78c:	9b b1       	in	r25, 0x0b	; 11
 78e:	84 e0       	ldi	r24, 0x04	; 4
 790:	89 27       	eor	r24, r25
 792:	8b b9       	out	0x0b, r24	; 11
	OCR2A = song[note_next];
 794:	e0 91 20 01 	lds	r30, 0x0120	; 0x800120 <note_next>
 798:	f0 e0       	ldi	r31, 0x00	; 0
 79a:	e0 50       	subi	r30, 0x00	; 0
 79c:	ff 4f       	sbci	r31, 0xFF	; 255
 79e:	80 81       	ld	r24, Z
 7a0:	80 93 b3 00 	sts	0x00B3, r24	; 0x8000b3 <__TEXT_REGION_LENGTH__+0x7e00b3>
	r2d_length++;
 7a4:	80 91 22 01 	lds	r24, 0x0122	; 0x800122 <r2d_length>
 7a8:	90 91 23 01 	lds	r25, 0x0123	; 0x800123 <r2d_length+0x1>
 7ac:	a0 91 24 01 	lds	r26, 0x0124	; 0x800124 <r2d_length+0x2>
 7b0:	b0 91 25 01 	lds	r27, 0x0125	; 0x800125 <r2d_length+0x3>
 7b4:	01 96       	adiw	r24, 0x01	; 1
 7b6:	a1 1d       	adc	r26, r1
 7b8:	b1 1d       	adc	r27, r1
 7ba:	80 93 22 01 	sts	0x0122, r24	; 0x800122 <r2d_length>
 7be:	90 93 23 01 	sts	0x0123, r25	; 0x800123 <r2d_length+0x1>
 7c2:	a0 93 24 01 	sts	0x0124, r26	; 0x800124 <r2d_length+0x2>
 7c6:	b0 93 25 01 	sts	0x0125, r27	; 0x800125 <r2d_length+0x3>
	//sei(); //magic?
 7ca:	ff 91       	pop	r31
 7cc:	ef 91       	pop	r30
 7ce:	bf 91       	pop	r27
 7d0:	af 91       	pop	r26
 7d2:	9f 91       	pop	r25
 7d4:	8f 91       	pop	r24
 7d6:	0f 90       	pop	r0
 7d8:	0b be       	out	0x3b, r0	; 59
 7da:	0f 90       	pop	r0
 7dc:	0f be       	out	0x3f, r0	; 63
 7de:	0f 90       	pop	r0
 7e0:	1f 90       	pop	r1
 7e2:	18 95       	reti

000007e4 <_exit>:
 7e4:	f8 94       	cli

000007e6 <__stop_program>:
 7e6:	ff cf       	rjmp	.-2      	; 0x7e6 <__stop_program>
