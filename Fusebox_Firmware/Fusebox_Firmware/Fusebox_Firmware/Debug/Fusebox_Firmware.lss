
Fusebox_Firmware.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000000c  00800100  000007d6  0000086a  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         000007d6  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000026  0080010c  0080010c  00000876  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00000876  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  000008a8  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000148  00000000  00000000  000008e8  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00001735  00000000  00000000  00000a30  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000f5b  00000000  00000000  00002165  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00000a98  00000000  00000000  000030c0  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000002bc  00000000  00000000  00003b58  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000009d5  00000000  00000000  00003e14  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    0000055c  00000000  00000000  000047e9  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000000e8  00000000  00000000  00004d45  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	49 c0       	rjmp	.+146    	; 0x94 <__ctors_end>
   2:	00 00       	nop
   4:	64 c0       	rjmp	.+200    	; 0xce <__bad_interrupt>
   6:	00 00       	nop
   8:	62 c0       	rjmp	.+196    	; 0xce <__bad_interrupt>
   a:	00 00       	nop
   c:	60 c0       	rjmp	.+192    	; 0xce <__bad_interrupt>
   e:	00 00       	nop
  10:	5e c0       	rjmp	.+188    	; 0xce <__bad_interrupt>
  12:	00 00       	nop
  14:	5c c0       	rjmp	.+184    	; 0xce <__bad_interrupt>
  16:	00 00       	nop
  18:	5a c0       	rjmp	.+180    	; 0xce <__bad_interrupt>
  1a:	00 00       	nop
  1c:	58 c0       	rjmp	.+176    	; 0xce <__bad_interrupt>
  1e:	00 00       	nop
  20:	56 c0       	rjmp	.+172    	; 0xce <__bad_interrupt>
  22:	00 00       	nop
  24:	76 c3       	rjmp	.+1772   	; 0x712 <__vector_9>
  26:	00 00       	nop
  28:	52 c0       	rjmp	.+164    	; 0xce <__bad_interrupt>
  2a:	00 00       	nop
  2c:	50 c0       	rjmp	.+160    	; 0xce <__bad_interrupt>
  2e:	00 00       	nop
  30:	73 c1       	rjmp	.+742    	; 0x318 <__vector_12>
  32:	00 00       	nop
  34:	4c c0       	rjmp	.+152    	; 0xce <__bad_interrupt>
  36:	00 00       	nop
  38:	4a c0       	rjmp	.+148    	; 0xce <__bad_interrupt>
  3a:	00 00       	nop
  3c:	48 c0       	rjmp	.+144    	; 0xce <__bad_interrupt>
  3e:	00 00       	nop
  40:	0a c3       	rjmp	.+1556   	; 0x656 <__vector_16>
  42:	00 00       	nop
  44:	44 c0       	rjmp	.+136    	; 0xce <__bad_interrupt>
  46:	00 00       	nop
  48:	42 c0       	rjmp	.+132    	; 0xce <__bad_interrupt>
  4a:	00 00       	nop
  4c:	40 c0       	rjmp	.+128    	; 0xce <__bad_interrupt>
  4e:	00 00       	nop
  50:	3e c0       	rjmp	.+124    	; 0xce <__bad_interrupt>
  52:	00 00       	nop
  54:	3c c0       	rjmp	.+120    	; 0xce <__bad_interrupt>
  56:	00 00       	nop
  58:	3a c0       	rjmp	.+116    	; 0xce <__bad_interrupt>
  5a:	00 00       	nop
  5c:	38 c0       	rjmp	.+112    	; 0xce <__bad_interrupt>
  5e:	00 00       	nop
  60:	36 c0       	rjmp	.+108    	; 0xce <__bad_interrupt>
  62:	00 00       	nop
  64:	44 c0       	rjmp	.+136    	; 0xee <__vector_25>
  66:	00 00       	nop
  68:	32 c0       	rjmp	.+100    	; 0xce <__bad_interrupt>
  6a:	00 00       	nop
  6c:	30 c0       	rjmp	.+96     	; 0xce <__bad_interrupt>
  6e:	00 00       	nop
  70:	2e c0       	rjmp	.+92     	; 0xce <__bad_interrupt>
  72:	00 00       	nop
  74:	2c c0       	rjmp	.+88     	; 0xce <__bad_interrupt>
  76:	00 00       	nop
  78:	2a c0       	rjmp	.+84     	; 0xce <__bad_interrupt>
  7a:	00 00       	nop
  7c:	28 c0       	rjmp	.+80     	; 0xce <__bad_interrupt>
  7e:	00 00       	nop
  80:	26 c0       	rjmp	.+76     	; 0xce <__bad_interrupt>
  82:	00 00       	nop
  84:	24 c0       	rjmp	.+72     	; 0xce <__bad_interrupt>
  86:	00 00       	nop
  88:	22 c0       	rjmp	.+68     	; 0xce <__bad_interrupt>
  8a:	00 00       	nop
  8c:	20 c0       	rjmp	.+64     	; 0xce <__bad_interrupt>
  8e:	00 00       	nop
  90:	1e c0       	rjmp	.+60     	; 0xce <__bad_interrupt>
	...

00000094 <__ctors_end>:
  94:	11 24       	eor	r1, r1
  96:	1f be       	out	0x3f, r1	; 63
  98:	cf ef       	ldi	r28, 0xFF	; 255
  9a:	d0 e1       	ldi	r29, 0x10	; 16
  9c:	de bf       	out	0x3e, r29	; 62
  9e:	cd bf       	out	0x3d, r28	; 61

000000a0 <__do_copy_data>:
  a0:	11 e0       	ldi	r17, 0x01	; 1
  a2:	a0 e0       	ldi	r26, 0x00	; 0
  a4:	b1 e0       	ldi	r27, 0x01	; 1
  a6:	e6 ed       	ldi	r30, 0xD6	; 214
  a8:	f7 e0       	ldi	r31, 0x07	; 7
  aa:	00 e0       	ldi	r16, 0x00	; 0
  ac:	0b bf       	out	0x3b, r16	; 59
  ae:	02 c0       	rjmp	.+4      	; 0xb4 <__do_copy_data+0x14>
  b0:	07 90       	elpm	r0, Z+
  b2:	0d 92       	st	X+, r0
  b4:	ac 30       	cpi	r26, 0x0C	; 12
  b6:	b1 07       	cpc	r27, r17
  b8:	d9 f7       	brne	.-10     	; 0xb0 <__do_copy_data+0x10>

000000ba <__do_clear_bss>:
  ba:	21 e0       	ldi	r18, 0x01	; 1
  bc:	ac e0       	ldi	r26, 0x0C	; 12
  be:	b1 e0       	ldi	r27, 0x01	; 1
  c0:	01 c0       	rjmp	.+2      	; 0xc4 <.do_clear_bss_start>

000000c2 <.do_clear_bss_loop>:
  c2:	1d 92       	st	X+, r1

000000c4 <.do_clear_bss_start>:
  c4:	a2 33       	cpi	r26, 0x32	; 50
  c6:	b2 07       	cpc	r27, r18
  c8:	e1 f7       	brne	.-8      	; 0xc2 <.do_clear_bss_loop>
  ca:	3b d1       	rcall	.+630    	; 0x342 <main>
  cc:	82 c3       	rjmp	.+1796   	; 0x7d2 <_exit>

000000ce <__bad_interrupt>:
  ce:	98 cf       	rjmp	.-208    	; 0x0 <__vectors>

000000d0 <adc_config>:
uint8_t adc_next = 0;



void adc_config(){
	ADMUX = (1<<REFS0); // AREF = AVcc and PF0 (ADC0) as input defined
  d0:	80 e4       	ldi	r24, 0x40	; 64
  d2:	80 93 7c 00 	sts	0x007C, r24	; 0x80007c <__TEXT_REGION_LENGTH__+0x7e007c>
	ADCSRA = (1<<ADEN) | (1<<ADPS2) | (0<<ADPS1) | (0<<ADPS0) | (1<<ADIE);
  d6:	ea e7       	ldi	r30, 0x7A	; 122
  d8:	f0 e0       	ldi	r31, 0x00	; 0
  da:	8c e8       	ldi	r24, 0x8C	; 140
  dc:	80 83       	st	Z, r24
	// ADEN enables ADC
	// ADIE enables ADC interrupt
	// ADPS (Prescaler) 16
	// see datasheet page 290
	ADCSRA |= (1<<ADSC); //start first conversion
  de:	80 81       	ld	r24, Z
  e0:	80 64       	ori	r24, 0x40	; 64
  e2:	80 83       	st	Z, r24
  e4:	08 95       	ret

000000e6 <adc_start_conversion>:
}

void adc_start_conversion(){
	//start next conversion with same config
	ADCSRA = (1<<ADEN) | (1<<ADIE) | (1<<ADSC);
  e6:	88 ec       	ldi	r24, 0xC8	; 200
  e8:	80 93 7a 00 	sts	0x007A, r24	; 0x80007a <__TEXT_REGION_LENGTH__+0x7e007a>
  ec:	08 95       	ret

000000ee <__vector_25>:
}

ISR(ADC_vect){
  ee:	1f 92       	push	r1
  f0:	0f 92       	push	r0
  f2:	0f b6       	in	r0, 0x3f	; 63
  f4:	0f 92       	push	r0
  f6:	11 24       	eor	r1, r1
  f8:	0b b6       	in	r0, 0x3b	; 59
  fa:	0f 92       	push	r0
  fc:	2f 93       	push	r18
  fe:	3f 93       	push	r19
 100:	4f 93       	push	r20
 102:	5f 93       	push	r21
 104:	6f 93       	push	r22
 106:	7f 93       	push	r23
 108:	8f 93       	push	r24
 10a:	9f 93       	push	r25
 10c:	af 93       	push	r26
 10e:	bf 93       	push	r27
 110:	ef 93       	push	r30
 112:	ff 93       	push	r31
	//cli();
	// store ADC result
	adc_values[adc_next] = ADC;// ADCL | (ADCH << 8); //low bit erst ablesen
 114:	80 91 0c 01 	lds	r24, 0x010C	; 0x80010c <__data_end>
 118:	e8 2f       	mov	r30, r24
 11a:	f0 e0       	ldi	r31, 0x00	; 0
 11c:	20 91 78 00 	lds	r18, 0x0078	; 0x800078 <__TEXT_REGION_LENGTH__+0x7e0078>
 120:	30 91 79 00 	lds	r19, 0x0079	; 0x800079 <__TEXT_REGION_LENGTH__+0x7e0079>
 124:	ee 0f       	add	r30, r30
 126:	ff 1f       	adc	r31, r31
 128:	e3 5d       	subi	r30, 0xD3	; 211
 12a:	fe 4f       	sbci	r31, 0xFE	; 254
 12c:	31 83       	std	Z+1, r19	; 0x01
 12e:	20 83       	st	Z, r18
	adc_next++;
 130:	8f 5f       	subi	r24, 0xFF	; 255
 132:	80 93 0c 01 	sts	0x010C, r24	; 0x80010c <__data_end>
	//adc_values[0] = (ADC*5)/1023;  //cant decide where in the code this should go without testing
	//adc_values[1] = ((ADC*5)/1023)+((10000*(ADC*5)/1023)/2500); //no way this is efficient, needs to be optimized later
	// reset index var
	//sei();
	if(adc_next == ADCVALUES){
 136:	82 30       	cpi	r24, 0x02	; 2
 138:	11 f4       	brne	.+4      	; 0x13e <__vector_25+0x50>
		adc_next = 0;
 13a:	10 92 0c 01 	sts	0x010C, r1	; 0x80010c <__data_end>
	}
	// select other ADC Input
	ADMUX = (1<<REFS0) | adc_next;
 13e:	80 91 0c 01 	lds	r24, 0x010C	; 0x80010c <__data_end>
 142:	80 64       	ori	r24, 0x40	; 64
 144:	80 93 7c 00 	sts	0x007C, r24	; 0x80007c <__TEXT_REGION_LENGTH__+0x7e007c>

	adc_start_conversion();
 148:	ce df       	rcall	.-100    	; 0xe6 <adc_start_conversion>
	//sei();
}
 14a:	ff 91       	pop	r31
 14c:	ef 91       	pop	r30
 14e:	bf 91       	pop	r27
 150:	af 91       	pop	r26
 152:	9f 91       	pop	r25
 154:	8f 91       	pop	r24
 156:	7f 91       	pop	r23
 158:	6f 91       	pop	r22
 15a:	5f 91       	pop	r21
 15c:	4f 91       	pop	r20
 15e:	3f 91       	pop	r19
 160:	2f 91       	pop	r18
 162:	0f 90       	pop	r0
 164:	0b be       	out	0x3b, r0	; 59
 166:	0f 90       	pop	r0
 168:	0f be       	out	0x3f, r0	; 63
 16a:	0f 90       	pop	r0
 16c:	1f 90       	pop	r1
 16e:	18 95       	reti

00000170 <adc_get>:

// getter for each adc var
uint16_t adc_get(uint8_t adc){
	
	return adc_values[adc];
 170:	e8 2f       	mov	r30, r24
 172:	f0 e0       	ldi	r31, 0x00	; 0
 174:	ee 0f       	add	r30, r30
 176:	ff 1f       	adc	r31, r31
 178:	e3 5d       	subi	r30, 0xD3	; 211
 17a:	fe 4f       	sbci	r31, 0xFE	; 254
}
 17c:	80 81       	ld	r24, Z
 17e:	91 81       	ldd	r25, Z+1	; 0x01
 180:	08 95       	ret

00000182 <can_check_free>:

uint8_t can_check_free(uint8_t mobnum){
	
	uint8_t mob_status = 0;
	
	if(mobnum >= 8){
 182:	88 30       	cpi	r24, 0x08	; 8
 184:	78 f0       	brcs	.+30     	; 0x1a4 <can_check_free+0x22>
		
		mob_status = !((CANEN1 >> (mobnum-8)) &1);
 186:	20 91 dd 00 	lds	r18, 0x00DD	; 0x8000dd <__TEXT_REGION_LENGTH__+0x7e00dd>
 18a:	90 e0       	ldi	r25, 0x00	; 0
 18c:	08 97       	sbiw	r24, 0x08	; 8
 18e:	30 e0       	ldi	r19, 0x00	; 0
 190:	02 c0       	rjmp	.+4      	; 0x196 <can_check_free+0x14>
 192:	35 95       	asr	r19
 194:	27 95       	ror	r18
 196:	8a 95       	dec	r24
 198:	e2 f7       	brpl	.-8      	; 0x192 <can_check_free+0x10>
 19a:	81 e0       	ldi	r24, 0x01	; 1
 19c:	20 ff       	sbrs	r18, 0
 19e:	0d c0       	rjmp	.+26     	; 0x1ba <can_check_free+0x38>
 1a0:	80 e0       	ldi	r24, 0x00	; 0
 1a2:	08 95       	ret


		} else {
		
		mob_status = !((CANEN2 >> mobnum) &1);
 1a4:	20 91 dc 00 	lds	r18, 0x00DC	; 0x8000dc <__TEXT_REGION_LENGTH__+0x7e00dc>
 1a8:	30 e0       	ldi	r19, 0x00	; 0
 1aa:	02 c0       	rjmp	.+4      	; 0x1b0 <can_check_free+0x2e>
 1ac:	35 95       	asr	r19
 1ae:	27 95       	ror	r18
 1b0:	8a 95       	dec	r24
 1b2:	e2 f7       	brpl	.-8      	; 0x1ac <can_check_free+0x2a>
 1b4:	81 e0       	ldi	r24, 0x01	; 1
 1b6:	20 fd       	sbrc	r18, 0
 1b8:	80 e0       	ldi	r24, 0x00	; 0
	}

	return mob_status;
	
}
 1ba:	08 95       	ret

000001bc <can_cfg>:
void can_cfg(){
	
	CANGCON = 0; // Disable CAN
 1bc:	10 92 d8 00 	sts	0x00D8, r1	; 0x8000d8 <__TEXT_REGION_LENGTH__+0x7e00d8>
	
	for (uint8_t mob = 0; mob < 15 ; mob++){//reset all mobs
 1c0:	40 e0       	ldi	r20, 0x00	; 0
 1c2:	29 c0       	rjmp	.+82     	; 0x216 <can_cfg+0x5a>
		CANPAGE = mob<<MOBNB0 | (1<<AINC);
 1c4:	80 e1       	ldi	r24, 0x10	; 16
 1c6:	48 9f       	mul	r20, r24
 1c8:	90 01       	movw	r18, r0
 1ca:	11 24       	eor	r1, r1
 1cc:	82 2f       	mov	r24, r18
 1ce:	88 60       	ori	r24, 0x08	; 8
 1d0:	80 93 ed 00 	sts	0x00ED, r24	; 0x8000ed <__TEXT_REGION_LENGTH__+0x7e00ed>
		CANSTMOB = 0;
 1d4:	10 92 ee 00 	sts	0x00EE, r1	; 0x8000ee <__TEXT_REGION_LENGTH__+0x7e00ee>
		CANCDMOB = 0;
 1d8:	10 92 ef 00 	sts	0x00EF, r1	; 0x8000ef <__TEXT_REGION_LENGTH__+0x7e00ef>
		CANIDT4 = 0;
 1dc:	10 92 f0 00 	sts	0x00F0, r1	; 0x8000f0 <__TEXT_REGION_LENGTH__+0x7e00f0>
		CANIDT3 = 0;
 1e0:	10 92 f1 00 	sts	0x00F1, r1	; 0x8000f1 <__TEXT_REGION_LENGTH__+0x7e00f1>
		CANIDT2 = 0;
 1e4:	10 92 f2 00 	sts	0x00F2, r1	; 0x8000f2 <__TEXT_REGION_LENGTH__+0x7e00f2>
		CANIDT1 = 0;
 1e8:	10 92 f3 00 	sts	0x00F3, r1	; 0x8000f3 <__TEXT_REGION_LENGTH__+0x7e00f3>
		CANIDM4 = 0;
 1ec:	10 92 f4 00 	sts	0x00F4, r1	; 0x8000f4 <__TEXT_REGION_LENGTH__+0x7e00f4>
		CANIDM3 = 0;
 1f0:	10 92 f5 00 	sts	0x00F5, r1	; 0x8000f5 <__TEXT_REGION_LENGTH__+0x7e00f5>
		CANIDM2 = 0;
 1f4:	10 92 f6 00 	sts	0x00F6, r1	; 0x8000f6 <__TEXT_REGION_LENGTH__+0x7e00f6>
		CANIDM1 = 0;
 1f8:	10 92 f7 00 	sts	0x00F7, r1	; 0x8000f7 <__TEXT_REGION_LENGTH__+0x7e00f7>
		for (uint8_t byte = 0; byte < 8; byte++){
 1fc:	80 e0       	ldi	r24, 0x00	; 0
 1fe:	08 c0       	rjmp	.+16     	; 0x210 <can_cfg+0x54>
			CANPAGE = mob<<MOBNB0 | 1<<AINC | byte;
 200:	98 2f       	mov	r25, r24
 202:	92 2b       	or	r25, r18
 204:	98 60       	ori	r25, 0x08	; 8
 206:	90 93 ed 00 	sts	0x00ED, r25	; 0x8000ed <__TEXT_REGION_LENGTH__+0x7e00ed>
			CANMSG = 0;
 20a:	10 92 fa 00 	sts	0x00FA, r1	; 0x8000fa <__TEXT_REGION_LENGTH__+0x7e00fa>
		CANIDT1 = 0;
		CANIDM4 = 0;
		CANIDM3 = 0;
		CANIDM2 = 0;
		CANIDM1 = 0;
		for (uint8_t byte = 0; byte < 8; byte++){
 20e:	8f 5f       	subi	r24, 0xFF	; 255
 210:	88 30       	cpi	r24, 0x08	; 8
 212:	b0 f3       	brcs	.-20     	; 0x200 <can_cfg+0x44>
}
void can_cfg(){
	
	CANGCON = 0; // Disable CAN
	
	for (uint8_t mob = 0; mob < 15 ; mob++){//reset all mobs
 214:	4f 5f       	subi	r20, 0xFF	; 255
 216:	4f 30       	cpi	r20, 0x0F	; 15
 218:	a8 f2       	brcs	.-86     	; 0x1c4 <can_cfg+0x8>
			CANPAGE = mob<<MOBNB0 | 1<<AINC | byte;
			CANMSG = 0;
		}
	}

	CANBT1 = 0x00;// Set Baudrate
 21a:	10 92 e2 00 	sts	0x00E2, r1	; 0x8000e2 <__TEXT_REGION_LENGTH__+0x7e00e2>
	CANBT2 = 0x0C;// 500kBaud according
 21e:	8c e0       	ldi	r24, 0x0C	; 12
 220:	80 93 e3 00 	sts	0x00E3, r24	; 0x8000e3 <__TEXT_REGION_LENGTH__+0x7e00e3>
	CANBT3 = 0x36;// to Datasheet S. 267
 224:	86 e3       	ldi	r24, 0x36	; 54
 226:	80 93 e4 00 	sts	0x00E4, r24	; 0x8000e4 <__TEXT_REGION_LENGTH__+0x7e00e4>

	CANGIE = 0;
 22a:	10 92 db 00 	sts	0x00DB, r1	; 0x8000db <__TEXT_REGION_LENGTH__+0x7e00db>

	CANGCON |= (1<<ENASTB); // Enable CAN
 22e:	e8 ed       	ldi	r30, 0xD8	; 216
 230:	f0 e0       	ldi	r31, 0x00	; 0
 232:	80 81       	ld	r24, Z
 234:	82 60       	ori	r24, 0x02	; 2
 236:	80 83       	st	Z, r24
 238:	08 95       	ret

0000023a <can_rx>:
	
	
	
}
void can_rx(struct CAN_MOB *to_receive, uint8_t *data){
 23a:	0f 93       	push	r16
 23c:	1f 93       	push	r17
 23e:	cf 93       	push	r28
 240:	df 93       	push	r29
 242:	ec 01       	movw	r28, r24
 244:	8b 01       	movw	r16, r22
	
	CANPAGE = to_receive->mob_number << MOBNB0;
 246:	8c 81       	ldd	r24, Y+4	; 0x04
 248:	82 95       	swap	r24
 24a:	80 7f       	andi	r24, 0xF0	; 240
 24c:	80 93 ed 00 	sts	0x00ED, r24	; 0x8000ed <__TEXT_REGION_LENGTH__+0x7e00ed>
	if (can_check_free(to_receive->mob_number)){
 250:	8c 81       	ldd	r24, Y+4	; 0x04
 252:	97 df       	rcall	.-210    	; 0x182 <can_check_free>
 254:	88 23       	and	r24, r24
 256:	71 f1       	breq	.+92     	; 0x2b4 <can_rx+0x7a>
		/* load the id 11 bit */
		CANIDT1 = to_receive->mob_id >>3;
 258:	88 81       	ld	r24, Y
 25a:	99 81       	ldd	r25, Y+1	; 0x01
 25c:	96 95       	lsr	r25
 25e:	87 95       	ror	r24
 260:	96 95       	lsr	r25
 262:	87 95       	ror	r24
 264:	96 95       	lsr	r25
 266:	87 95       	ror	r24
 268:	80 93 f3 00 	sts	0x00F3, r24	; 0x8000f3 <__TEXT_REGION_LENGTH__+0x7e00f3>
		CANIDT2 = (to_receive->mob_id << 5)&0b11100000;
 26c:	88 81       	ld	r24, Y
 26e:	82 95       	swap	r24
 270:	88 0f       	add	r24, r24
 272:	80 7e       	andi	r24, 0xE0	; 224
 274:	80 93 f2 00 	sts	0x00F2, r24	; 0x8000f2 <__TEXT_REGION_LENGTH__+0x7e00f2>
		CANIDT3 = 0;
 278:	10 92 f1 00 	sts	0x00F1, r1	; 0x8000f1 <__TEXT_REGION_LENGTH__+0x7e00f1>
		CANIDT4 = 1<<RTRTAG;
 27c:	84 e0       	ldi	r24, 0x04	; 4
 27e:	80 93 f0 00 	sts	0x00F0, r24	; 0x8000f0 <__TEXT_REGION_LENGTH__+0x7e00f0>
		CANIDM1 = to_receive->mob_idmask >>3;
 282:	8a 81       	ldd	r24, Y+2	; 0x02
 284:	9b 81       	ldd	r25, Y+3	; 0x03
 286:	96 95       	lsr	r25
 288:	87 95       	ror	r24
 28a:	96 95       	lsr	r25
 28c:	87 95       	ror	r24
 28e:	96 95       	lsr	r25
 290:	87 95       	ror	r24
 292:	80 93 f7 00 	sts	0x00F7, r24	; 0x8000f7 <__TEXT_REGION_LENGTH__+0x7e00f7>
		CANIDM2 = (to_receive->mob_idmask <<5)&0b11100000;
 296:	8a 81       	ldd	r24, Y+2	; 0x02
 298:	82 95       	swap	r24
 29a:	88 0f       	add	r24, r24
 29c:	80 7e       	andi	r24, 0xE0	; 224
 29e:	80 93 f6 00 	sts	0x00F6, r24	; 0x8000f6 <__TEXT_REGION_LENGTH__+0x7e00f6>
		CANIDM3 = 0;
 2a2:	10 92 f5 00 	sts	0x00F5, r1	; 0x8000f5 <__TEXT_REGION_LENGTH__+0x7e00f5>
		CANIDM4 = 0;
 2a6:	10 92 f4 00 	sts	0x00F4, r1	; 0x8000f4 <__TEXT_REGION_LENGTH__+0x7e00f4>
		CANCDMOB = (1 << CONMOB1) | (1 << CONMOB0)| (1<<DLC3);
 2aa:	88 ec       	ldi	r24, 0xC8	; 200
 2ac:	80 93 ef 00 	sts	0x00EF, r24	; 0x8000ef <__TEXT_REGION_LENGTH__+0x7e00ef>
		CANSTMOB = 0;
 2b0:	10 92 ee 00 	sts	0x00EE, r1	; 0x8000ee <__TEXT_REGION_LENGTH__+0x7e00ee>
	CANGCON |= (1<<ENASTB); // Enable CAN
	
	
	
}
void can_rx(struct CAN_MOB *to_receive, uint8_t *data){
 2b4:	20 e0       	ldi	r18, 0x00	; 0
 2b6:	10 c0       	rjmp	.+32     	; 0x2d8 <can_rx+0x9e>
		CANCDMOB = (1 << CONMOB1) | (1 << CONMOB0)| (1<<DLC3);
		CANSTMOB = 0;
	}
	
	for(uint8_t byte = 0; byte <8; byte++){
		CANPAGE = (to_receive->mob_number << MOBNB0) | (1 << AINC) | byte;
 2b8:	8c 81       	ldd	r24, Y+4	; 0x04
 2ba:	30 e1       	ldi	r19, 0x10	; 16
 2bc:	83 9f       	mul	r24, r19
 2be:	c0 01       	movw	r24, r0
 2c0:	11 24       	eor	r1, r1
 2c2:	82 2b       	or	r24, r18
 2c4:	88 60       	ori	r24, 0x08	; 8
 2c6:	80 93 ed 00 	sts	0x00ED, r24	; 0x8000ed <__TEXT_REGION_LENGTH__+0x7e00ed>
		data[byte] = CANMSG;
 2ca:	f8 01       	movw	r30, r16
 2cc:	e2 0f       	add	r30, r18
 2ce:	f1 1d       	adc	r31, r1
 2d0:	80 91 fa 00 	lds	r24, 0x00FA	; 0x8000fa <__TEXT_REGION_LENGTH__+0x7e00fa>
 2d4:	80 83       	st	Z, r24
		CANIDM4 = 0;
		CANCDMOB = (1 << CONMOB1) | (1 << CONMOB0)| (1<<DLC3);
		CANSTMOB = 0;
	}
	
	for(uint8_t byte = 0; byte <8; byte++){
 2d6:	2f 5f       	subi	r18, 0xFF	; 255
 2d8:	28 30       	cpi	r18, 0x08	; 8
 2da:	70 f3       	brcs	.-36     	; 0x2b8 <can_rx+0x7e>
		CANPAGE = (to_receive->mob_number << MOBNB0) | (1 << AINC) | byte;
		data[byte] = CANMSG;
	}
	
	
}
 2dc:	df 91       	pop	r29
 2de:	cf 91       	pop	r28
 2e0:	1f 91       	pop	r17
 2e2:	0f 91       	pop	r16
 2e4:	08 95       	ret

000002e6 <timer1_config>:
		fan_duty = (temperature*63)/100;
	}	
}

void timer1_config(){	
DDRB |= (1<<PB6);			// setting COM1nx Bits not necessary because we can also toggle/set pins using the ISR, here the Fan PWM cable is already on the Pin toggled by those bits											
 2e6:	84 b1       	in	r24, 0x04	; 4
 2e8:	80 64       	ori	r24, 0x40	; 64
 2ea:	84 b9       	out	0x04, r24	; 4
TCCR1A = (1<<WGM11) | (1<<WGM10) | (0<<COM1A1) | (1<<COM1A0) | (1<<COM1B1);	//mode 15, prescaler 8, non inverted mode => page 138 - 139  
 2ec:	83 e6       	ldi	r24, 0x63	; 99
 2ee:	80 93 80 00 	sts	0x0080, r24	; 0x800080 <__TEXT_REGION_LENGTH__+0x7e0080>
TCCR1B = (1<<WGM13) | (1<<WGM12) | (1<<CS11);								// Fast PWM description => page 128
 2f2:	8a e1       	ldi	r24, 0x1A	; 26
 2f4:	80 93 81 00 	sts	0x0081, r24	; 0x800081 <__TEXT_REGION_LENGTH__+0x7e0081>
TIMSK1 = (1<<OCIE1A);														//Output Compare interrupt flag will be set whenever OCR1A is reached
 2f8:	82 e0       	ldi	r24, 0x02	; 2
 2fa:	80 93 6f 00 	sts	0x006F, r24	; 0x80006f <__TEXT_REGION_LENGTH__+0x7e006f>
OCR1A = 63;													// TOP  16000000/(8*(1+64)) = 30769.23077 Hz = ~30kHz => page 130   with TOP value 62+1 the resolution is 6 bit => page 128
 2fe:	8f e3       	ldi	r24, 0x3F	; 63
 300:	90 e0       	ldi	r25, 0x00	; 0
 302:	90 93 89 00 	sts	0x0089, r25	; 0x800089 <__TEXT_REGION_LENGTH__+0x7e0089>
 306:	80 93 88 00 	sts	0x0088, r24	; 0x800088 <__TEXT_REGION_LENGTH__+0x7e0088>
OCR1B = 10;                         	// BOTTOM
 30a:	8a e0       	ldi	r24, 0x0A	; 10
 30c:	90 e0       	ldi	r25, 0x00	; 0
 30e:	90 93 8b 00 	sts	0x008B, r25	; 0x80008b <__TEXT_REGION_LENGTH__+0x7e008b>
 312:	80 93 8a 00 	sts	0x008A, r24	; 0x80008a <__TEXT_REGION_LENGTH__+0x7e008a>
 316:	08 95       	ret

00000318 <__vector_12>:
}

ISR(TIMER1_COMPA_vect){									//ISR for the timer 1, updating the duty cycle
 318:	1f 92       	push	r1
 31a:	0f 92       	push	r0
 31c:	0f b6       	in	r0, 0x3f	; 63
 31e:	0f 92       	push	r0
 320:	11 24       	eor	r1, r1
 322:	8f 93       	push	r24
 324:	9f 93       	push	r25
//cli();
OCR1B = fan_duty;
 326:	80 91 31 01 	lds	r24, 0x0131	; 0x800131 <fan_duty>
 32a:	90 e0       	ldi	r25, 0x00	; 0
 32c:	90 93 8b 00 	sts	0x008B, r25	; 0x80008b <__TEXT_REGION_LENGTH__+0x7e008b>
 330:	80 93 8a 00 	sts	0x008A, r24	; 0x80008a <__TEXT_REGION_LENGTH__+0x7e008a>
//sei();
 334:	9f 91       	pop	r25
 336:	8f 91       	pop	r24
 338:	0f 90       	pop	r0
 33a:	0f be       	out	0x3f, r0	; 63
 33c:	0f 90       	pop	r0
 33e:	1f 90       	pop	r1
 340:	18 95       	reti

00000342 <main>:
extern volatile unsigned char DRV_EN;
uint16_t apps = 0;
int16_t ac_current = 0;
uint16_t current_limit = 15; //in Ampere

int main(void){
 342:	cf 93       	push	r28
 344:	df 93       	push	r29
 346:	cd b7       	in	r28, 0x3d	; 61
 348:	de b7       	in	r29, 0x3e	; 62
 34a:	a7 97       	sbiw	r28, 0x27	; 39
 34c:	0f b6       	in	r0, 0x3f	; 63
 34e:	f8 94       	cli
 350:	de bf       	out	0x3e, r29	; 62
 352:	0f be       	out	0x3f, r0	; 63
 354:	cd bf       	out	0x3d, r28	; 61

sys_timer_config();
 356:	72 d1       	rcall	.+740    	; 0x63c <sys_timer_config>
port_config();
 358:	68 d1       	rcall	.+720    	; 0x62a <port_config>
can_cfg();
 35a:	30 df       	rcall	.-416    	; 0x1bc <can_cfg>
adc_config();
 35c:	b9 de       	rcall	.-654    	; 0xd0 <adc_config>
 35e:	d0 d1       	rcall	.+928    	; 0x700 <timer2_config>
timer2_config();
 360:	c2 df       	rcall	.-124    	; 0x2e6 <timer1_config>
 362:	83 ed       	ldi	r24, 0xD3	; 211
timer1_config();
 364:	90 e3       	ldi	r25, 0x30	; 48
 366:	01 97       	sbiw	r24, 0x01	; 1
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 368:	f1 f7       	brne	.-4      	; 0x366 <main+0x24>
 36a:	00 c0       	rjmp	.+0      	; 0x36c <main+0x2a>
 36c:	00 00       	nop
 36e:	80 e0       	ldi	r24, 0x00	; 0
 370:	94 e0       	ldi	r25, 0x04	; 4
 372:	9a 83       	std	Y+2, r25	; 0x02
can_Fusebox4_mob.mob_idmask = 0xFF; //sent
can_Fusebox4_mob.mob_number = 4;
uint8_t Fusebox4_databytes[8] = {0, 0, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF};

struct CAN_MOB can_SHR0_mob;
can_SHR0_mob.mob_id = 0x400;
 374:	89 83       	std	Y+1, r24	; 0x01
 376:	8f ef       	ldi	r24, 0xFF	; 255
 378:	97 e0       	ldi	r25, 0x07	; 7
 37a:	9c 83       	std	Y+4, r25	; 0x04
can_SHR0_mob.mob_idmask = 0b11111111111; //receive with no filer?
 37c:	8b 83       	std	Y+3, r24	; 0x03
 37e:	25 e0       	ldi	r18, 0x05	; 5
 380:	2d 83       	std	Y+5, r18	; 0x05
 382:	20 e2       	ldi	r18, 0x20	; 32
can_SHR0_mob.mob_number = 5;  //IDs might be wrong
 384:	34 e0       	ldi	r19, 0x04	; 4
 386:	3f 87       	std	Y+15, r19	; 0x0f
uint8_t SHR0_databytes[8];

struct CAN_MOB can_SHB0_mob;
can_SHB0_mob.mob_id = 0x420;
 388:	2e 87       	std	Y+14, r18	; 0x0e
 38a:	99 8b       	std	Y+17, r25	; 0x11
 38c:	88 8b       	std	Y+16, r24	; 0x10
 38e:	86 e0       	ldi	r24, 0x06	; 6
can_SHB0_mob.mob_idmask = 0b11111111111; //receive with no filter?
 390:	8a 8b       	std	Y+18, r24	; 0x12
 392:	80 e0       	ldi	r24, 0x00	; 0
can_SHB0_mob.mob_number = 6;
 394:	95 e0       	ldi	r25, 0x05	; 5
 396:	9c 8f       	std	Y+28, r25	; 0x1c
uint8_t SHB0_databytes[8];

struct CAN_MOB can_DIC0_mob;	
can_DIC0_mob.mob_id = 0x500;
 398:	8b 8f       	std	Y+27, r24	; 0x1b
 39a:	8f ef       	ldi	r24, 0xFF	; 255
 39c:	9f ef       	ldi	r25, 0xFF	; 255
 39e:	9e 8f       	std	Y+30, r25	; 0x1e
can_DIC0_mob.mob_idmask = 0xffff;
 3a0:	8d 8f       	std	Y+29, r24	; 0x1d
 3a2:	87 e0       	ldi	r24, 0x07	; 7
 3a4:	8f 8f       	std	Y+31, r24	; 0x1f
 3a6:	78 94       	sei
can_DIC0_mob.mob_number = 7;
 3a8:	13 c0       	rjmp	.+38     	; 0x3d0 <main+0x8e>
 3aa:	88 3e       	cpi	r24, 0xE8	; 232
uint8_t DIC0_databytes[8];

//timer1_config();
sei();
 3ac:	93 40       	sbci	r25, 0x03	; 3
// 		}//end of if containing the decrementing condition = 1
// 	} //end first 3s of arming seq (while)
		
	//} //end of 6s arming seq
	
	while (sys_time < 2000){
 3ae:	a1 05       	cpc	r26, r1
// 		if (sys_time == 5000){
// 			increment_flag = 2;
// 		}
		if (sys_time == 1000){
 3b0:	b1 05       	cpc	r27, r1
 3b2:	19 f4       	brne	.+6      	; 0x3ba <main+0x78>
 3b4:	81 e0       	ldi	r24, 0x01	; 1
 3b6:	80 93 11 01 	sts	0x0111, r24	; 0x800111 <increment_flag>
			increment_flag = 1;
 3ba:	80 91 11 01 	lds	r24, 0x0111	; 0x800111 <increment_flag>
 3be:	81 11       	cpse	r24, r1
		}
		if(increment_flag == 0){
 3c0:	03 c0       	rjmp	.+6      	; 0x3c8 <main+0x86>
 3c2:	94 e1       	ldi	r25, 0x14	; 20
 3c4:	90 93 31 01 	sts	0x0131, r25	; 0x800131 <fan_duty>
			fan_duty = 20;
 3c8:	81 30       	cpi	r24, 0x01	; 1
 3ca:	11 f4       	brne	.+4      	; 0x3d0 <main+0x8e>
 3cc:	10 92 31 01 	sts	0x0131, r1	; 0x800131 <fan_duty>
		} //end of if containing the incrementing condition = 0
		if (increment_flag == 1){	
 3d0:	80 91 23 01 	lds	r24, 0x0123	; 0x800123 <sys_time>
			fan_duty = 0;
 3d4:	90 91 24 01 	lds	r25, 0x0124	; 0x800124 <sys_time+0x1>
// 		}//end of if containing the decrementing condition = 1
// 	} //end first 3s of arming seq (while)
		
	//} //end of 6s arming seq
	
	while (sys_time < 2000){
 3d8:	a0 91 25 01 	lds	r26, 0x0125	; 0x800125 <sys_time+0x2>
 3dc:	b0 91 26 01 	lds	r27, 0x0126	; 0x800126 <sys_time+0x3>
 3e0:	80 3d       	cpi	r24, 0xD0	; 208
 3e2:	17 e0       	ldi	r17, 0x07	; 7
 3e4:	91 07       	cpc	r25, r17
 3e6:	a1 05       	cpc	r26, r1
 3e8:	b1 05       	cpc	r27, r1
 3ea:	f8 f2       	brcs	.-66     	; 0x3aa <main+0x68>
 3ec:	80 91 23 01 	lds	r24, 0x0123	; 0x800123 <sys_time>
 3f0:	90 91 24 01 	lds	r25, 0x0124	; 0x800124 <sys_time+0x1>
// 		}
	} //end first XXXms of arming seq (while)
	
	
	while (1){
		if(TIME_PASSED_10_MS){			// (sys_time - time_old) > 10
 3f4:	a0 91 25 01 	lds	r26, 0x0125	; 0x800125 <sys_time+0x2>
 3f8:	b0 91 26 01 	lds	r27, 0x0126	; 0x800126 <sys_time+0x3>
 3fc:	40 91 1e 01 	lds	r20, 0x011E	; 0x80011e <time_old>
 400:	50 91 1f 01 	lds	r21, 0x011F	; 0x80011f <time_old+0x1>
 404:	60 91 20 01 	lds	r22, 0x0120	; 0x800120 <time_old+0x2>
 408:	70 91 21 01 	lds	r23, 0x0121	; 0x800121 <time_old+0x3>
 40c:	8c 01       	movw	r16, r24
 40e:	9d 01       	movw	r18, r26
 410:	04 1b       	sub	r16, r20
 412:	15 0b       	sbc	r17, r21
 414:	26 0b       	sbc	r18, r22
 416:	37 0b       	sbc	r19, r23
 418:	0b 30       	cpi	r16, 0x0B	; 11
 41a:	11 05       	cpc	r17, r1
 41c:	21 05       	cpc	r18, r1
 41e:	31 05       	cpc	r19, r1
 420:	08 f4       	brcc	.+2      	; 0x424 <__LOCK_REGION_LENGTH__+0x24>
 422:	cf c0       	rjmp	.+414    	; 0x5c2 <__LOCK_REGION_LENGTH__+0x1c2>
 424:	80 93 1e 01 	sts	0x011E, r24	; 0x80011e <time_old>
 428:	90 93 1f 01 	sts	0x011F, r25	; 0x80011f <time_old+0x1>
			time_old = sys_time; 
 42c:	a0 93 20 01 	sts	0x0120, r26	; 0x800120 <time_old+0x2>
 430:	b0 93 21 01 	sts	0x0121, r27	; 0x800121 <time_old+0x3>
 434:	80 91 1a 01 	lds	r24, 0x011A	; 0x80011a <time_old_100ms>
 438:	90 91 1b 01 	lds	r25, 0x011B	; 0x80011b <time_old_100ms+0x1>
			time_old_100ms++;   //FIND BETTER NAME, WHY OLD??
 43c:	a0 91 1c 01 	lds	r26, 0x011C	; 0x80011c <time_old_100ms+0x2>
 440:	b0 91 1d 01 	lds	r27, 0x011D	; 0x80011d <time_old_100ms+0x3>
 444:	01 96       	adiw	r24, 0x01	; 1
 446:	a1 1d       	adc	r26, r1
 448:	b1 1d       	adc	r27, r1
 44a:	80 93 1a 01 	sts	0x011A, r24	; 0x80011a <time_old_100ms>
 44e:	90 93 1b 01 	sts	0x011B, r25	; 0x80011b <time_old_100ms+0x1>
 452:	a0 93 1c 01 	sts	0x011C, r26	; 0x80011c <time_old_100ms+0x2>
 456:	b0 93 1d 01 	sts	0x011D, r27	; 0x80011d <time_old_100ms+0x3>
 45a:	80 91 16 01 	lds	r24, 0x0116	; 0x800116 <time_200ms>
 45e:	90 91 17 01 	lds	r25, 0x0117	; 0x800117 <time_200ms+0x1>
			time_200ms++;
 462:	a0 91 18 01 	lds	r26, 0x0118	; 0x800118 <time_200ms+0x2>
 466:	b0 91 19 01 	lds	r27, 0x0119	; 0x800119 <time_200ms+0x3>
 46a:	01 96       	adiw	r24, 0x01	; 1
 46c:	a1 1d       	adc	r26, r1
 46e:	b1 1d       	adc	r27, r1
 470:	80 93 16 01 	sts	0x0116, r24	; 0x800116 <time_200ms>
 474:	90 93 17 01 	sts	0x0117, r25	; 0x800117 <time_200ms+0x1>
 478:	a0 93 18 01 	sts	0x0118, r26	; 0x800118 <time_200ms+0x2>
 47c:	b0 93 19 01 	sts	0x0119, r27	; 0x800119 <time_200ms+0x3>
 480:	80 91 12 01 	lds	r24, 0x0112	; 0x800112 <test_timer1>
 484:	90 91 13 01 	lds	r25, 0x0113	; 0x800113 <test_timer1+0x1>
			test_timer1++;
 488:	a0 91 14 01 	lds	r26, 0x0114	; 0x800114 <test_timer1+0x2>
 48c:	b0 91 15 01 	lds	r27, 0x0115	; 0x800115 <test_timer1+0x3>
 490:	01 96       	adiw	r24, 0x01	; 1
 492:	a1 1d       	adc	r26, r1
 494:	b1 1d       	adc	r27, r1
 496:	80 93 12 01 	sts	0x0112, r24	; 0x800112 <test_timer1>
 49a:	90 93 13 01 	sts	0x0113, r25	; 0x800113 <test_timer1+0x1>
 49e:	a0 93 14 01 	sts	0x0114, r26	; 0x800114 <test_timer1+0x2>
 4a2:	b0 93 15 01 	sts	0x0115, r27	; 0x800115 <test_timer1+0x3>
 4a6:	2c b1       	in	r18, 0x0c	; 12
 4a8:	80 b1       	in	r24, 0x00	; 0
 4aa:	90 e0       	ldi	r25, 0x00	; 0
			
			if (FUSES_ALL_IN){	
 4ac:	98 2f       	mov	r25, r24
 4ae:	88 27       	eor	r24, r24
 4b0:	9f 70       	andi	r25, 0x0F	; 15
 4b2:	82 2b       	or	r24, r18
 4b4:	8f 3f       	cpi	r24, 0xFF	; 255
 4b6:	9f 40       	sbci	r25, 0x0F	; 15
 4b8:	11 f4       	brne	.+4      	; 0x4be <__LOCK_REGION_LENGTH__+0xbe>
 4ba:	f2 d0       	rcall	.+484    	; 0x6a0 <fault_not_detected>
				fault_not_detected();																					
 4bc:	01 c0       	rjmp	.+2      	; 0x4c0 <__LOCK_REGION_LENGTH__+0xc0>
 4be:	f4 d0       	rcall	.+488    	; 0x6a8 <fault_detected>
			}																															
			else{
				fault_detected();	
 4c0:	be 01       	movw	r22, r28
 4c2:	6d 5e       	subi	r22, 0xED	; 237
	//MOVE THESE NOTES TO THE MAIN DESCRIPTION THAT WILL COME ON TOP OF THE C FILE JUST LIKE IN THE FAN POWER UNIT 					
//fuse_read_out()&0xff;			// input &0xff gives you the first byte (8bit) (least significant byte)  
//(fuse_read_out()>>8)&0xff;		//shifting 1 byte to the right gives us the next 8 bit bundle, now we've read the full 16 bit value

			//can_rx(&can_R2D_mob, R2D_databytes);
			can_rx(&can_SHB0_mob, SHB0_databytes);
 4c4:	7f 4f       	sbci	r23, 0xFF	; 255
 4c6:	ce 01       	movw	r24, r28
 4c8:	0e 96       	adiw	r24, 0x0e	; 14
 4ca:	b7 de       	rcall	.-658    	; 0x23a <can_rx>
 4cc:	be 01       	movw	r22, r28
 4ce:	6a 5f       	subi	r22, 0xFA	; 250
			can_rx(&can_SHR0_mob, SHR0_databytes); //receive at same freq as sender right?
 4d0:	7f 4f       	sbci	r23, 0xFF	; 255
 4d2:	ce 01       	movw	r24, r28
 4d4:	01 96       	adiw	r24, 0x01	; 1
 4d6:	b1 de       	rcall	.-670    	; 0x23a <can_rx>
 4d8:	be 01       	movw	r22, r28
 4da:	60 5e       	subi	r22, 0xE0	; 224
			can_rx(&can_DIC0_mob, DIC0_databytes);
 4dc:	7f 4f       	sbci	r23, 0xFF	; 255
 4de:	ce 01       	movw	r24, r28
 4e0:	4b 96       	adiw	r24, 0x1b	; 27
 4e2:	ab de       	rcall	.-682    	; 0x23a <can_rx>
 4e4:	8e 81       	ldd	r24, Y+6	; 0x06
 4e6:	60 e0       	ldi	r22, 0x00	; 0
 4e8:	7f 81       	ldd	r23, Y+7	; 0x07
			
			apps = (SHR0_databytes[0]) + (SHR0_databytes[1] << 8)/2;
 4ea:	77 23       	and	r23, r23
 4ec:	14 f4       	brge	.+4      	; 0x4f2 <__LOCK_REGION_LENGTH__+0xf2>
 4ee:	6f 5f       	subi	r22, 0xFF	; 255
 4f0:	7f 4f       	sbci	r23, 0xFF	; 255
 4f2:	75 95       	asr	r23
 4f4:	67 95       	ror	r22
 4f6:	68 0f       	add	r22, r24
 4f8:	71 1d       	adc	r23, r1
 4fa:	70 93 10 01 	sts	0x0110, r23	; 0x800110 <apps+0x1>
 4fe:	60 93 0f 01 	sts	0x010F, r22	; 0x80010f <apps>
 502:	80 91 00 01 	lds	r24, 0x0100	; 0x800100 <__DATA_REGION_ORIGIN__>
			
			ac_current = calculate_ac_current(current_limit, apps);
 506:	90 91 01 01 	lds	r25, 0x0101	; 0x800101 <__DATA_REGION_ORIGIN__+0x1>
 50a:	e2 d0       	rcall	.+452    	; 0x6d0 <calculate_ac_current>
 50c:	90 93 0e 01 	sts	0x010E, r25	; 0x80010e <ac_current+0x1>
 510:	80 93 0d 01 	sts	0x010D, r24	; 0x80010d <ac_current>
			
 			Fusebox0_databytes[0]	=	adc_get(0)&0xff			;
 514:	80 e0       	ldi	r24, 0x00	; 0
 516:	2c de       	rcall	.-936    	; 0x170 <adc_get>
 518:	80 e0       	ldi	r24, 0x00	; 0
			Fusebox0_databytes[1]	=	(adc_get(0)>>8)&0xff	;	
 51a:	2a de       	rcall	.-940    	; 0x170 <adc_get>
 51c:	81 e0       	ldi	r24, 0x01	; 1
 51e:	28 de       	rcall	.-944    	; 0x170 <adc_get>
 			Fusebox0_databytes[2]	=	adc_get(1)&0xff			;	
 520:	81 e0       	ldi	r24, 0x01	; 1
 522:	26 de       	rcall	.-948    	; 0x170 <adc_get>
 524:	ce 01       	movw	r24, r28
 			Fusebox0_databytes[3]	=	(adc_get(1)>>8)&0xff	; 
 526:	80 96       	adiw	r24, 0x20	; 32
 528:	c3 d0       	rcall	.+390    	; 0x6b0 <tractive_system_activate>
 52a:	2c b1       	in	r18, 0x0c	; 12
			Fusebox3_databytes[0] = ac_current;
			Fusebox3_databytes[1] = (ac_current >> 8);
			Fusebox4_databytes[0] = current_limit;
			Fusebox4_databytes[1] = (current_limit >> 8);
			
			tractive_system_activate(DIC0_databytes);
 52c:	80 b1       	in	r24, 0x00	; 0
 52e:	90 e0       	ldi	r25, 0x00	; 0
 530:	98 2f       	mov	r25, r24
 532:	88 27       	eor	r24, r24
			//can_tx(&can_Fusebox3_mob, Fusebox3_databytes);	//(AC Current)
			//can_tx(&can_Fusebox4_mob, Fusebox4_databytes);	//(AC Current Limit)
			
		//	R2D_pressed = R2D_databytes[2];
											// define CAR_IS_READY_TO_DRIVE [combines the 3 conditions]
			if ((fuse_read_out() & 0xFFF) < 0xFFF){  //debugging purposes fuse acts as my switch, NO MACRO NOW THE 3 CONDITIONS COME HERE: READY TO DRIVE, POWER ON and BUTTON PRESSED?
 534:	9f 70       	andi	r25, 0x0F	; 15
 536:	82 2b       	or	r24, r18
 538:	8f 3f       	cpi	r24, 0xFF	; 255
 53a:	9f 40       	sbci	r25, 0x0F	; 15
 53c:	28 f4       	brcc	.+10     	; 0x548 <__LOCK_REGION_LENGTH__+0x148>
 53e:	e0 eb       	ldi	r30, 0xB0	; 176
 540:	f0 e0       	ldi	r31, 0x00	; 0
 542:	80 81       	ld	r24, Z
 544:	84 60       	ori	r24, 0x04	; 4
 546:	80 83       	st	Z, r24
 					START_TIMER_2; 				
 548:	80 91 29 01 	lds	r24, 0x0129	; 0x800129 <r2d_length>
 54c:	90 91 2a 01 	lds	r25, 0x012A	; 0x80012a <r2d_length+0x1>
 550:	a0 91 2b 01 	lds	r26, 0x012B	; 0x80012b <r2d_length+0x2>
			}  

				//define SOUND_STILL_GOING? r2dl < xxx  // <= make that macro and a function that caclulates the time or soemthing, input time in seconds (1-3s) and it will calculate the value for the condition 2,5 seconds = 23000 or something (need to measure it better)
			if (r2d_length < 23000/*<noise_length (change r2dlength to something like r2d_ticks*/){ // under 3 seconds (tested with a stopwatch) as long as the button is not held longer than a singular press => will lead into a 2nd cycle starting 
 554:	b0 91 2c 01 	lds	r27, 0x012C	; 0x80012c <r2d_length+0x3>
 558:	88 3d       	cpi	r24, 0xD8	; 216
 55a:	99 45       	sbci	r25, 0x59	; 89
 55c:	a1 05       	cpc	r26, r1
 55e:	b1 05       	cpc	r27, r1
 560:	a0 f4       	brcc	.+40     	; 0x58a <__LOCK_REGION_LENGTH__+0x18a>
 562:	80 91 28 01 	lds	r24, 0x0128	; 0x800128 <note_length>
 566:	8f 5f       	subi	r24, 0xFF	; 255
 568:	80 93 28 01 	sts	0x0128, r24	; 0x800128 <note_length>
									
				note_length++;
 56c:	85 30       	cpi	r24, 0x05	; 5
 56e:	39 f4       	brne	.+14     	; 0x57e <__LOCK_REGION_LENGTH__+0x17e>
 570:	10 92 28 01 	sts	0x0128, r1	; 0x800128 <note_length>
 574:	80 91 27 01 	lds	r24, 0x0127	; 0x800127 <note_next>

 				if (note_length == 5){
 578:	8f 5f       	subi	r24, 0xFF	; 255
				note_length = 0;
 57a:	80 93 27 01 	sts	0x0127, r24	; 0x800127 <note_next>
 				note_next++;
 57e:	80 91 27 01 	lds	r24, 0x0127	; 0x800127 <note_next>
 582:	8a 30       	cpi	r24, 0x0A	; 10
 584:	11 f4       	brne	.+4      	; 0x58a <__LOCK_REGION_LENGTH__+0x18a>
 586:	10 92 27 01 	sts	0x0127, r1	; 0x800127 <note_next>
				}
 				if (note_next == 10){
 58a:	80 91 29 01 	lds	r24, 0x0129	; 0x800129 <r2d_length>
 58e:	90 91 2a 01 	lds	r25, 0x012A	; 0x80012a <r2d_length+0x1>
 				note_next = 0;
 592:	a0 91 2b 01 	lds	r26, 0x012B	; 0x80012b <r2d_length+0x2>
 				}	
			}	
			if (r2d_length >= 23000){   //turn into an else{}
 596:	b0 91 2c 01 	lds	r27, 0x012C	; 0x80012c <r2d_length+0x3>
 59a:	88 3d       	cpi	r24, 0xD8	; 216
 59c:	99 45       	sbci	r25, 0x59	; 89
 59e:	a1 05       	cpc	r26, r1
 5a0:	b1 05       	cpc	r27, r1
 5a2:	78 f0       	brcs	.+30     	; 0x5c2 <__LOCK_REGION_LENGTH__+0x1c2>
 5a4:	e0 eb       	ldi	r30, 0xB0	; 176
 5a6:	f0 e0       	ldi	r31, 0x00	; 0
 5a8:	80 81       	ld	r24, Z
 5aa:	8b 7f       	andi	r24, 0xFB	; 251
 5ac:	80 83       	st	Z, r24
				TCCR2A &= ~(1<<CS22);
 5ae:	10 92 29 01 	sts	0x0129, r1	; 0x800129 <r2d_length>
 5b2:	10 92 2a 01 	sts	0x012A, r1	; 0x80012a <r2d_length+0x1>
 5b6:	10 92 2b 01 	sts	0x012B, r1	; 0x80012b <r2d_length+0x2>
				r2d_length = 0;
 5ba:	10 92 2c 01 	sts	0x012C, r1	; 0x80012c <r2d_length+0x3>
 5be:	10 92 27 01 	sts	0x0127, r1	; 0x800127 <note_next>
 5c2:	80 91 1a 01 	lds	r24, 0x011A	; 0x80011a <time_old_100ms>
 5c6:	90 91 1b 01 	lds	r25, 0x011B	; 0x80011b <time_old_100ms+0x1>
				note_next = 0;
 5ca:	a0 91 1c 01 	lds	r26, 0x011C	; 0x80011c <time_old_100ms+0x2>
			}
	
		}	//end of 10 ms cycle
	
		if (/*time_old_100ms >= 100*/TIME_PASSED_100_MS){ //100 ms
 5ce:	b0 91 1d 01 	lds	r27, 0x011D	; 0x80011d <time_old_100ms+0x3>
 5d2:	84 36       	cpi	r24, 0x64	; 100
 5d4:	91 05       	cpc	r25, r1
 5d6:	a1 05       	cpc	r26, r1
 5d8:	b1 05       	cpc	r27, r1
 5da:	60 f0       	brcs	.+24     	; 0x5f4 <__LOCK_REGION_LENGTH__+0x1f4>
 5dc:	10 92 1a 01 	sts	0x011A, r1	; 0x80011a <time_old_100ms>
 5e0:	10 92 1b 01 	sts	0x011B, r1	; 0x80011b <time_old_100ms+0x1>
 			time_old_100ms = 0;
 5e4:	10 92 1c 01 	sts	0x011C, r1	; 0x80011c <time_old_100ms+0x2>
 5e8:	10 92 1d 01 	sts	0x011D, r1	; 0x80011d <time_old_100ms+0x3>
 5ec:	2f d0       	rcall	.+94     	; 0x64c <sys_tick_heart>
 5ee:	8f e0       	ldi	r24, 0x0F	; 15
 5f0:	80 93 31 01 	sts	0x0131, r24	; 0x800131 <fan_duty>
 			sys_tick_heart();  //remove the sys_, tick_heart obvious by itself
 5f4:	80 91 16 01 	lds	r24, 0x0116	; 0x800116 <time_200ms>
			// for (int8_t x = 5; x < 40; x++){  //testing the range of values to alter the duty%
 				//int16_t CAN_temperature = x; //from can
 				uint8_t temperature = x;//(uint8_t) CAN_temperature;
 			//	_delay_ms(8);   //use sys timer later
 			//	fan_power_unit_PWM_control(temperature, fan_duty); 	
			 fan_duty = (temperature*63)/100;
 5f8:	90 91 17 01 	lds	r25, 0x0117	; 0x800117 <time_200ms+0x1>
 5fc:	a0 91 18 01 	lds	r26, 0x0118	; 0x800118 <time_200ms+0x2>
 			//} //end of for
		
			// }
			 
 		}  //end of 100ms
		if (time_200ms >= 20){
 600:	b0 91 19 01 	lds	r27, 0x0119	; 0x800119 <time_200ms+0x3>
 604:	44 97       	sbiw	r24, 0x14	; 20
 606:	a1 05       	cpc	r26, r1
 608:	b1 05       	cpc	r27, r1
 60a:	08 f4       	brcc	.+2      	; 0x60e <__LOCK_REGION_LENGTH__+0x20e>
 60c:	ef ce       	rjmp	.-546    	; 0x3ec <main+0xaa>
 60e:	10 92 16 01 	sts	0x0116, r1	; 0x800116 <time_200ms>
 612:	10 92 17 01 	sts	0x0117, r1	; 0x800117 <time_200ms+0x1>
 616:	10 92 18 01 	sts	0x0118, r1	; 0x800118 <time_200ms+0x2>
			time_200ms = 0;
 61a:	10 92 19 01 	sts	0x0119, r1	; 0x800119 <time_200ms+0x3>
 61e:	86 b1       	in	r24, 0x06	; 6
 620:	80 b1       	in	r24, 0x00	; 0
 622:	8c b1       	in	r24, 0x0c	; 12
 624:	8c b1       	in	r24, 0x0c	; 12
 626:	80 b1       	in	r24, 0x00	; 0
			
			Fusebox1_databytes[0]	=	SCI_read_out()			;
 628:	e1 ce       	rjmp	.-574    	; 0x3ec <main+0xaa>

0000062a <port_config>:
volatile unsigned long sys_time = 0;

volatile unsigned char DRV_EN = 0;

void port_config(){  //0 input, 1 output
	DDRA = 0;   //Fuse Read Out Inputs
 62a:	11 b8       	out	0x01, r1	; 1
	DDRB = 0 | (1<<PB0) |(1<<PB2) | (1<<PB3) | (1<<PB4) | (1<<PB5); //WP, fan and LED outputs
 62c:	8d e3       	ldi	r24, 0x3D	; 61
 62e:	84 b9       	out	0x04, r24	; 4
	DDRC = 0; // Shutdown circuit just like FRO is an input 
 630:	17 b8       	out	0x07, r1	; 7
	DDRD = 0 | (1<<PD2) | (1<<PD3) | (1<<PD5); /*| (1<<PD6);SET TO 0?*/ // timer for the buzzer and can outputs, PD5 transmits to CAN, PD6 is a receiver
 632:	8c e2       	ldi	r24, 0x2C	; 44
 634:	8a b9       	out	0x0a, r24	; 10
	DDRE = 0; //Fuse Read Out Inputs
 636:	1d b8       	out	0x0d, r1	; 13
	DDRF = 0; //JTAG and 2 ADC readings inputs
 638:	10 ba       	out	0x10, r1	; 16
 63a:	08 95       	ret

0000063c <sys_timer_config>:
}

void sys_timer_config(void)
{
	//CTC-Mode, /64
	TCCR0A = 0 | (1<<WGM01) | (1<<CS01) | (1<<CS00);
 63c:	8b e0       	ldi	r24, 0x0B	; 11
 63e:	84 bd       	out	0x24, r24	; 36
	//Compare value for 1ms (Formula in Datasheet)
	OCR0A = 249;
 640:	89 ef       	ldi	r24, 0xF9	; 249
 642:	87 bd       	out	0x27, r24	; 39
	//Compare Interrupt Enable
	TIMSK0 = 0 | (1<<OCIE0A);
 644:	82 e0       	ldi	r24, 0x02	; 2
 646:	80 93 6e 00 	sts	0x006E, r24	; 0x80006e <__TEXT_REGION_LENGTH__+0x7e006e>
 64a:	08 95       	ret

0000064c <sys_tick_heart>:
}

void sys_tick_heart(){
	PORTB ^= (1<<PB4); //toggle the Heart led on Pin 4, will be used in the super loop in main.c to indicade that the loop is running correctly	
 64c:	95 b1       	in	r25, 0x05	; 5
 64e:	80 e1       	ldi	r24, 0x10	; 16
 650:	89 27       	eor	r24, r25
 652:	85 b9       	out	0x05, r24	; 5
 654:	08 95       	ret

00000656 <__vector_16>:
};

ISR(TIMER0_COMP_vect){
 656:	1f 92       	push	r1
 658:	0f 92       	push	r0
 65a:	0f b6       	in	r0, 0x3f	; 63
 65c:	0f 92       	push	r0
 65e:	11 24       	eor	r1, r1
 660:	8f 93       	push	r24
 662:	9f 93       	push	r25
 664:	af 93       	push	r26
 666:	bf 93       	push	r27
//	cli();
	sys_time++;  //system time incremented on each interrupt flag from the CTC mode compare register => every OCR0A
 668:	80 91 23 01 	lds	r24, 0x0123	; 0x800123 <sys_time>
 66c:	90 91 24 01 	lds	r25, 0x0124	; 0x800124 <sys_time+0x1>
 670:	a0 91 25 01 	lds	r26, 0x0125	; 0x800125 <sys_time+0x2>
 674:	b0 91 26 01 	lds	r27, 0x0126	; 0x800126 <sys_time+0x3>
 678:	01 96       	adiw	r24, 0x01	; 1
 67a:	a1 1d       	adc	r26, r1
 67c:	b1 1d       	adc	r27, r1
 67e:	80 93 23 01 	sts	0x0123, r24	; 0x800123 <sys_time>
 682:	90 93 24 01 	sts	0x0124, r25	; 0x800124 <sys_time+0x1>
 686:	a0 93 25 01 	sts	0x0125, r26	; 0x800125 <sys_time+0x2>
 68a:	b0 93 26 01 	sts	0x0126, r27	; 0x800126 <sys_time+0x3>
	//sei();
}
 68e:	bf 91       	pop	r27
 690:	af 91       	pop	r26
 692:	9f 91       	pop	r25
 694:	8f 91       	pop	r24
 696:	0f 90       	pop	r0
 698:	0f be       	out	0x3f, r0	; 63
 69a:	0f 90       	pop	r0
 69c:	1f 90       	pop	r1
 69e:	18 95       	reti

000006a0 <fault_not_detected>:

void fault_not_detected(){	
	PORTB &= ~(1<<PB3); //turn off red led in case of no fault
 6a0:	85 b1       	in	r24, 0x05	; 5
 6a2:	87 7f       	andi	r24, 0xF7	; 247
 6a4:	85 b9       	out	0x05, r24	; 5
 6a6:	08 95       	ret

000006a8 <fault_detected>:
}

void fault_detected(){
	PORTB |= (1<<PB3); //turn on red led when called (fault present)
 6a8:	85 b1       	in	r24, 0x05	; 5
 6aa:	88 60       	ori	r24, 0x08	; 8
 6ac:	85 b9       	out	0x05, r24	; 5
 6ae:	08 95       	ret

000006b0 <tractive_system_activate>:
}

void tractive_system_activate(uint8_t *data){
	START_TIMER_2;
 6b0:	e0 eb       	ldi	r30, 0xB0	; 176
 6b2:	f0 e0       	ldi	r31, 0x00	; 0
 6b4:	20 81       	ld	r18, Z
 6b6:	24 60       	ori	r18, 0x04	; 4
 6b8:	20 83       	st	Z, r18
	if (data[1]){
 6ba:	fc 01       	movw	r30, r24
 6bc:	81 81       	ldd	r24, Z+1	; 0x01
 6be:	88 23       	and	r24, r24
 6c0:	21 f0       	breq	.+8      	; 0x6ca <tractive_system_activate+0x1a>
		DRV_EN = 1;
 6c2:	81 e0       	ldi	r24, 0x01	; 1
 6c4:	80 93 22 01 	sts	0x0122, r24	; 0x800122 <DRV_EN>
 6c8:	08 95       	ret
	}else{
		DRV_EN = 0;
 6ca:	10 92 22 01 	sts	0x0122, r1	; 0x800122 <DRV_EN>
 6ce:	08 95       	ret

000006d0 <calculate_ac_current>:
	}
}

int16_t calculate_ac_current(uint16_t limit, uint16_t value){
 6d0:	fc 01       	movw	r30, r24
 6d2:	cb 01       	movw	r24, r22
		
	return ((int16_t)limit * ((int16_t)value/100) * 10);
 6d4:	64 e6       	ldi	r22, 0x64	; 100
 6d6:	70 e0       	ldi	r23, 0x00	; 0
 6d8:	55 d0       	rcall	.+170    	; 0x784 <__divmodhi4>
 6da:	6e 9f       	mul	r22, r30
 6dc:	90 01       	movw	r18, r0
 6de:	6f 9f       	mul	r22, r31
 6e0:	30 0d       	add	r19, r0
 6e2:	7e 9f       	mul	r23, r30
 6e4:	30 0d       	add	r19, r0
 6e6:	11 24       	eor	r1, r1
 6e8:	c9 01       	movw	r24, r18
 6ea:	88 0f       	add	r24, r24
 6ec:	99 1f       	adc	r25, r25
 6ee:	22 0f       	add	r18, r18
 6f0:	33 1f       	adc	r19, r19
 6f2:	22 0f       	add	r18, r18
 6f4:	33 1f       	adc	r19, r19
 6f6:	22 0f       	add	r18, r18
 6f8:	33 1f       	adc	r19, r19
}
 6fa:	82 0f       	add	r24, r18
 6fc:	93 1f       	adc	r25, r19
 6fe:	08 95       	ret

00000700 <timer2_config>:
		if (note_length == 5){
			note_length = 0;
			note_next++;
		}
		if (note_next == 10){
			note_next = 0;
 700:	e0 eb       	ldi	r30, 0xB0	; 176
 702:	f0 e0       	ldi	r31, 0x00	; 0
 704:	80 81       	ld	r24, Z
 706:	88 60       	ori	r24, 0x08	; 8
 708:	80 83       	st	Z, r24
 70a:	82 e0       	ldi	r24, 0x02	; 2
 70c:	80 93 70 00 	sts	0x0070, r24	; 0x800070 <__TEXT_REGION_LENGTH__+0x7e0070>
 710:	08 95       	ret

00000712 <__vector_9>:
		}
}

ISR(TIMER2_COMP_vect){ //isr for timer2 
 712:	1f 92       	push	r1
 714:	0f 92       	push	r0
 716:	0f b6       	in	r0, 0x3f	; 63
 718:	0f 92       	push	r0
 71a:	11 24       	eor	r1, r1
 71c:	0b b6       	in	r0, 0x3b	; 59
 71e:	0f 92       	push	r0
 720:	8f 93       	push	r24
 722:	9f 93       	push	r25
 724:	af 93       	push	r26
 726:	bf 93       	push	r27
 728:	ef 93       	push	r30
 72a:	ff 93       	push	r31
	//cli(); // if cli() and sei() at the end are deployed, the code slows down immensly (longer sounds etc, but the overall r2d length does not get affected at all since its inside the ISR)
	PORTD ^= (1<<PD2);
 72c:	9b b1       	in	r25, 0x0b	; 11
 72e:	84 e0       	ldi	r24, 0x04	; 4
 730:	89 27       	eor	r24, r25
 732:	8b b9       	out	0x0b, r24	; 11
	OCR2A = song[note_next];
 734:	e0 91 27 01 	lds	r30, 0x0127	; 0x800127 <note_next>
 738:	f0 e0       	ldi	r31, 0x00	; 0
 73a:	ee 5f       	subi	r30, 0xFE	; 254
 73c:	fe 4f       	sbci	r31, 0xFE	; 254
 73e:	80 81       	ld	r24, Z
 740:	80 93 b3 00 	sts	0x00B3, r24	; 0x8000b3 <__TEXT_REGION_LENGTH__+0x7e00b3>
	r2d_length++;
 744:	80 91 29 01 	lds	r24, 0x0129	; 0x800129 <r2d_length>
 748:	90 91 2a 01 	lds	r25, 0x012A	; 0x80012a <r2d_length+0x1>
 74c:	a0 91 2b 01 	lds	r26, 0x012B	; 0x80012b <r2d_length+0x2>
 750:	b0 91 2c 01 	lds	r27, 0x012C	; 0x80012c <r2d_length+0x3>
 754:	01 96       	adiw	r24, 0x01	; 1
 756:	a1 1d       	adc	r26, r1
 758:	b1 1d       	adc	r27, r1
 75a:	80 93 29 01 	sts	0x0129, r24	; 0x800129 <r2d_length>
 75e:	90 93 2a 01 	sts	0x012A, r25	; 0x80012a <r2d_length+0x1>
 762:	a0 93 2b 01 	sts	0x012B, r26	; 0x80012b <r2d_length+0x2>
 766:	b0 93 2c 01 	sts	0x012C, r27	; 0x80012c <r2d_length+0x3>
	//sei(); //magic?
 76a:	ff 91       	pop	r31
 76c:	ef 91       	pop	r30
 76e:	bf 91       	pop	r27
 770:	af 91       	pop	r26
 772:	9f 91       	pop	r25
 774:	8f 91       	pop	r24
 776:	0f 90       	pop	r0
 778:	0b be       	out	0x3b, r0	; 59
 77a:	0f 90       	pop	r0
 77c:	0f be       	out	0x3f, r0	; 63
 77e:	0f 90       	pop	r0
 780:	1f 90       	pop	r1
 782:	18 95       	reti

00000784 <__divmodhi4>:
 784:	97 fb       	bst	r25, 7
 786:	07 2e       	mov	r0, r23
 788:	16 f4       	brtc	.+4      	; 0x78e <__divmodhi4+0xa>
 78a:	00 94       	com	r0
 78c:	06 d0       	rcall	.+12     	; 0x79a <__divmodhi4_neg1>
 78e:	77 fd       	sbrc	r23, 7
 790:	08 d0       	rcall	.+16     	; 0x7a2 <__divmodhi4_neg2>
 792:	0b d0       	rcall	.+22     	; 0x7aa <__udivmodhi4>
 794:	07 fc       	sbrc	r0, 7
 796:	05 d0       	rcall	.+10     	; 0x7a2 <__divmodhi4_neg2>
 798:	3e f4       	brtc	.+14     	; 0x7a8 <__divmodhi4_exit>

0000079a <__divmodhi4_neg1>:
 79a:	90 95       	com	r25
 79c:	81 95       	neg	r24
 79e:	9f 4f       	sbci	r25, 0xFF	; 255
 7a0:	08 95       	ret

000007a2 <__divmodhi4_neg2>:
 7a2:	70 95       	com	r23
 7a4:	61 95       	neg	r22
 7a6:	7f 4f       	sbci	r23, 0xFF	; 255

000007a8 <__divmodhi4_exit>:
 7a8:	08 95       	ret

000007aa <__udivmodhi4>:
 7aa:	aa 1b       	sub	r26, r26
 7ac:	bb 1b       	sub	r27, r27
 7ae:	51 e1       	ldi	r21, 0x11	; 17
 7b0:	07 c0       	rjmp	.+14     	; 0x7c0 <__udivmodhi4_ep>

000007b2 <__udivmodhi4_loop>:
 7b2:	aa 1f       	adc	r26, r26
 7b4:	bb 1f       	adc	r27, r27
 7b6:	a6 17       	cp	r26, r22
 7b8:	b7 07       	cpc	r27, r23
 7ba:	10 f0       	brcs	.+4      	; 0x7c0 <__udivmodhi4_ep>
 7bc:	a6 1b       	sub	r26, r22
 7be:	b7 0b       	sbc	r27, r23

000007c0 <__udivmodhi4_ep>:
 7c0:	88 1f       	adc	r24, r24
 7c2:	99 1f       	adc	r25, r25
 7c4:	5a 95       	dec	r21
 7c6:	a9 f7       	brne	.-22     	; 0x7b2 <__udivmodhi4_loop>
 7c8:	80 95       	com	r24
 7ca:	90 95       	com	r25
 7cc:	bc 01       	movw	r22, r24
 7ce:	cd 01       	movw	r24, r26
 7d0:	08 95       	ret

000007d2 <_exit>:
 7d2:	f8 94       	cli

000007d4 <__stop_program>:
 7d4:	ff cf       	rjmp	.-2      	; 0x7d4 <__stop_program>
