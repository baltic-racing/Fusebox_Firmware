
Fusebox_Firmware.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000000c  00800100  000006cc  00000760  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         000006cc  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000018  0080010c  0080010c  0000076c  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  0000076c  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  0000079c  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000138  00000000  00000000  000007dc  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00001431  00000000  00000000  00000914  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000e6d  00000000  00000000  00001d45  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00000adb  00000000  00000000  00002bb2  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  0000029c  00000000  00000000  00003690  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000007a6  00000000  00000000  0000392c  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    0000047c  00000000  00000000  000040d2  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000000d8  00000000  00000000  0000454e  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	49 c0       	rjmp	.+146    	; 0x94 <__ctors_end>
   2:	00 00       	nop
   4:	64 c0       	rjmp	.+200    	; 0xce <__bad_interrupt>
   6:	00 00       	nop
   8:	62 c0       	rjmp	.+196    	; 0xce <__bad_interrupt>
   a:	00 00       	nop
   c:	60 c0       	rjmp	.+192    	; 0xce <__bad_interrupt>
   e:	00 00       	nop
  10:	5e c0       	rjmp	.+188    	; 0xce <__bad_interrupt>
  12:	00 00       	nop
  14:	5c c0       	rjmp	.+184    	; 0xce <__bad_interrupt>
  16:	00 00       	nop
  18:	5a c0       	rjmp	.+180    	; 0xce <__bad_interrupt>
  1a:	00 00       	nop
  1c:	58 c0       	rjmp	.+176    	; 0xce <__bad_interrupt>
  1e:	00 00       	nop
  20:	56 c0       	rjmp	.+172    	; 0xce <__bad_interrupt>
  22:	00 00       	nop
  24:	18 c3       	rjmp	.+1584   	; 0x656 <__vector_9>
  26:	00 00       	nop
  28:	52 c0       	rjmp	.+164    	; 0xce <__bad_interrupt>
  2a:	00 00       	nop
  2c:	50 c0       	rjmp	.+160    	; 0xce <__bad_interrupt>
  2e:	00 00       	nop
  30:	bb c1       	rjmp	.+886    	; 0x3a8 <__vector_12>
  32:	00 00       	nop
  34:	4c c0       	rjmp	.+152    	; 0xce <__bad_interrupt>
  36:	00 00       	nop
  38:	4a c0       	rjmp	.+148    	; 0xce <__bad_interrupt>
  3a:	00 00       	nop
  3c:	48 c0       	rjmp	.+144    	; 0xce <__bad_interrupt>
  3e:	00 00       	nop
  40:	d4 c2       	rjmp	.+1448   	; 0x5ea <__vector_16>
  42:	00 00       	nop
  44:	44 c0       	rjmp	.+136    	; 0xce <__bad_interrupt>
  46:	00 00       	nop
  48:	42 c0       	rjmp	.+132    	; 0xce <__bad_interrupt>
  4a:	00 00       	nop
  4c:	40 c0       	rjmp	.+128    	; 0xce <__bad_interrupt>
  4e:	00 00       	nop
  50:	3e c0       	rjmp	.+124    	; 0xce <__bad_interrupt>
  52:	00 00       	nop
  54:	3c c0       	rjmp	.+120    	; 0xce <__bad_interrupt>
  56:	00 00       	nop
  58:	3a c0       	rjmp	.+116    	; 0xce <__bad_interrupt>
  5a:	00 00       	nop
  5c:	38 c0       	rjmp	.+112    	; 0xce <__bad_interrupt>
  5e:	00 00       	nop
  60:	36 c0       	rjmp	.+108    	; 0xce <__bad_interrupt>
  62:	00 00       	nop
  64:	44 c0       	rjmp	.+136    	; 0xee <__vector_25>
  66:	00 00       	nop
  68:	32 c0       	rjmp	.+100    	; 0xce <__bad_interrupt>
  6a:	00 00       	nop
  6c:	30 c0       	rjmp	.+96     	; 0xce <__bad_interrupt>
  6e:	00 00       	nop
  70:	2e c0       	rjmp	.+92     	; 0xce <__bad_interrupt>
  72:	00 00       	nop
  74:	2c c0       	rjmp	.+88     	; 0xce <__bad_interrupt>
  76:	00 00       	nop
  78:	2a c0       	rjmp	.+84     	; 0xce <__bad_interrupt>
  7a:	00 00       	nop
  7c:	28 c0       	rjmp	.+80     	; 0xce <__bad_interrupt>
  7e:	00 00       	nop
  80:	26 c0       	rjmp	.+76     	; 0xce <__bad_interrupt>
  82:	00 00       	nop
  84:	24 c0       	rjmp	.+72     	; 0xce <__bad_interrupt>
  86:	00 00       	nop
  88:	22 c0       	rjmp	.+68     	; 0xce <__bad_interrupt>
  8a:	00 00       	nop
  8c:	20 c0       	rjmp	.+64     	; 0xce <__bad_interrupt>
  8e:	00 00       	nop
  90:	1e c0       	rjmp	.+60     	; 0xce <__bad_interrupt>
	...

00000094 <__ctors_end>:
  94:	11 24       	eor	r1, r1
  96:	1f be       	out	0x3f, r1	; 63
  98:	cf ef       	ldi	r28, 0xFF	; 255
  9a:	d0 e1       	ldi	r29, 0x10	; 16
  9c:	de bf       	out	0x3e, r29	; 62
  9e:	cd bf       	out	0x3d, r28	; 61

000000a0 <__do_copy_data>:
  a0:	11 e0       	ldi	r17, 0x01	; 1
  a2:	a0 e0       	ldi	r26, 0x00	; 0
  a4:	b1 e0       	ldi	r27, 0x01	; 1
  a6:	ec ec       	ldi	r30, 0xCC	; 204
  a8:	f6 e0       	ldi	r31, 0x06	; 6
  aa:	00 e0       	ldi	r16, 0x00	; 0
  ac:	0b bf       	out	0x3b, r16	; 59
  ae:	02 c0       	rjmp	.+4      	; 0xb4 <__do_copy_data+0x14>
  b0:	07 90       	elpm	r0, Z+
  b2:	0d 92       	st	X+, r0
  b4:	ac 30       	cpi	r26, 0x0C	; 12
  b6:	b1 07       	cpc	r27, r17
  b8:	d9 f7       	brne	.-10     	; 0xb0 <__do_copy_data+0x10>

000000ba <__do_clear_bss>:
  ba:	21 e0       	ldi	r18, 0x01	; 1
  bc:	ac e0       	ldi	r26, 0x0C	; 12
  be:	b1 e0       	ldi	r27, 0x01	; 1
  c0:	01 c0       	rjmp	.+2      	; 0xc4 <.do_clear_bss_start>

000000c2 <.do_clear_bss_loop>:
  c2:	1d 92       	st	X+, r1

000000c4 <.do_clear_bss_start>:
  c4:	a4 32       	cpi	r26, 0x24	; 36
  c6:	b2 07       	cpc	r27, r18
  c8:	e1 f7       	brne	.-8      	; 0xc2 <.do_clear_bss_loop>
  ca:	83 d1       	rcall	.+774    	; 0x3d2 <main>
  cc:	fd c2       	rjmp	.+1530   	; 0x6c8 <_exit>

000000ce <__bad_interrupt>:
  ce:	98 cf       	rjmp	.-208    	; 0x0 <__vectors>

000000d0 <adc_config>:
uint8_t adc_next = 0;



void adc_config(){
	ADMUX = (1<<REFS0); // AREF = AVcc and PF0 (ADC0) as input defined
  d0:	80 e4       	ldi	r24, 0x40	; 64
  d2:	80 93 7c 00 	sts	0x007C, r24	; 0x80007c <__TEXT_REGION_LENGTH__+0x7e007c>
	ADCSRA = (1<<ADEN) | (1<<ADPS2) | (0<<ADPS1) | (0<<ADPS0) | (1<<ADIE);
  d6:	ea e7       	ldi	r30, 0x7A	; 122
  d8:	f0 e0       	ldi	r31, 0x00	; 0
  da:	8c e8       	ldi	r24, 0x8C	; 140
  dc:	80 83       	st	Z, r24
	// ADEN enables ADC
	// ADIE enables ADC interrupt
	// ADPS (Prescaler) 16
	// see datasheet page 290
	ADCSRA |= (1<<ADSC); //start first conversion
  de:	80 81       	ld	r24, Z
  e0:	80 64       	ori	r24, 0x40	; 64
  e2:	80 83       	st	Z, r24
  e4:	08 95       	ret

000000e6 <adc_start_conversion>:
}

void adc_start_conversion(){
	//start next conversion with same config
	ADCSRA = (1<<ADEN) | (1<<ADIE) | (1<<ADSC);
  e6:	88 ec       	ldi	r24, 0xC8	; 200
  e8:	80 93 7a 00 	sts	0x007A, r24	; 0x80007a <__TEXT_REGION_LENGTH__+0x7e007a>
  ec:	08 95       	ret

000000ee <__vector_25>:
}

ISR(ADC_vect){
  ee:	1f 92       	push	r1
  f0:	0f 92       	push	r0
  f2:	0f b6       	in	r0, 0x3f	; 63
  f4:	0f 92       	push	r0
  f6:	11 24       	eor	r1, r1
  f8:	0b b6       	in	r0, 0x3b	; 59
  fa:	0f 92       	push	r0
  fc:	2f 93       	push	r18
  fe:	3f 93       	push	r19
 100:	4f 93       	push	r20
 102:	5f 93       	push	r21
 104:	6f 93       	push	r22
 106:	7f 93       	push	r23
 108:	8f 93       	push	r24
 10a:	9f 93       	push	r25
 10c:	af 93       	push	r26
 10e:	bf 93       	push	r27
 110:	ef 93       	push	r30
 112:	ff 93       	push	r31
	//cli();
	// store ADC result
	adc_values[adc_next] = ADC;// ADCL | (ADCH << 8); //low bit erst ablesen
 114:	80 91 0c 01 	lds	r24, 0x010C	; 0x80010c <__data_end>
 118:	e8 2f       	mov	r30, r24
 11a:	f0 e0       	ldi	r31, 0x00	; 0
 11c:	20 91 78 00 	lds	r18, 0x0078	; 0x800078 <__TEXT_REGION_LENGTH__+0x7e0078>
 120:	30 91 79 00 	lds	r19, 0x0079	; 0x800079 <__TEXT_REGION_LENGTH__+0x7e0079>
 124:	ee 0f       	add	r30, r30
 126:	ff 1f       	adc	r31, r31
 128:	e0 5e       	subi	r30, 0xE0	; 224
 12a:	fe 4f       	sbci	r31, 0xFE	; 254
 12c:	31 83       	std	Z+1, r19	; 0x01
 12e:	20 83       	st	Z, r18
	adc_next++;
 130:	8f 5f       	subi	r24, 0xFF	; 255
 132:	80 93 0c 01 	sts	0x010C, r24	; 0x80010c <__data_end>
	//adc_values[0] = (ADC*5)/1023;  //cant decide where in the code this should go without testing
	//adc_values[1] = ((ADC*5)/1023)+((10000*(ADC*5)/1023)/2500); //no way this is efficient, needs to be optimized later
	// reset index var
	//sei();
	if(adc_next == ADCVALUES){
 136:	82 30       	cpi	r24, 0x02	; 2
 138:	11 f4       	brne	.+4      	; 0x13e <__vector_25+0x50>
		adc_next = 0;
 13a:	10 92 0c 01 	sts	0x010C, r1	; 0x80010c <__data_end>
	}
	// select other ADC Input
	ADMUX = (1<<REFS0) | adc_next;
 13e:	80 91 0c 01 	lds	r24, 0x010C	; 0x80010c <__data_end>
 142:	80 64       	ori	r24, 0x40	; 64
 144:	80 93 7c 00 	sts	0x007C, r24	; 0x80007c <__TEXT_REGION_LENGTH__+0x7e007c>

	adc_start_conversion();
 148:	ce df       	rcall	.-100    	; 0xe6 <adc_start_conversion>
	
}
 14a:	ff 91       	pop	r31
 14c:	ef 91       	pop	r30
 14e:	bf 91       	pop	r27
 150:	af 91       	pop	r26
 152:	9f 91       	pop	r25
 154:	8f 91       	pop	r24
 156:	7f 91       	pop	r23
 158:	6f 91       	pop	r22
 15a:	5f 91       	pop	r21
 15c:	4f 91       	pop	r20
 15e:	3f 91       	pop	r19
 160:	2f 91       	pop	r18
 162:	0f 90       	pop	r0
 164:	0b be       	out	0x3b, r0	; 59
 166:	0f 90       	pop	r0
 168:	0f be       	out	0x3f, r0	; 63
 16a:	0f 90       	pop	r0
 16c:	1f 90       	pop	r1
 16e:	18 95       	reti

00000170 <adc_get>:

// getter for each adc var
uint16_t adc_get(uint8_t adc){
	
	return adc_values[adc];
 170:	e8 2f       	mov	r30, r24
 172:	f0 e0       	ldi	r31, 0x00	; 0
 174:	ee 0f       	add	r30, r30
 176:	ff 1f       	adc	r31, r31
 178:	e0 5e       	subi	r30, 0xE0	; 224
 17a:	fe 4f       	sbci	r31, 0xFE	; 254
}
 17c:	80 81       	ld	r24, Z
 17e:	91 81       	ldd	r25, Z+1	; 0x01
 180:	08 95       	ret

00000182 <can_check_free>:

uint8_t can_check_free(uint8_t mobnum){
	
	uint8_t mob_status = 0;
	
	if(mobnum >7){
 182:	88 30       	cpi	r24, 0x08	; 8
 184:	78 f0       	brcs	.+30     	; 0x1a4 <can_check_free+0x22>
		
		mob_status = !((CANEN1 >> (mobnum-8)) &1);
 186:	20 91 dd 00 	lds	r18, 0x00DD	; 0x8000dd <__TEXT_REGION_LENGTH__+0x7e00dd>
 18a:	90 e0       	ldi	r25, 0x00	; 0
 18c:	08 97       	sbiw	r24, 0x08	; 8
 18e:	30 e0       	ldi	r19, 0x00	; 0
 190:	02 c0       	rjmp	.+4      	; 0x196 <can_check_free+0x14>
 192:	35 95       	asr	r19
 194:	27 95       	ror	r18
 196:	8a 95       	dec	r24
 198:	e2 f7       	brpl	.-8      	; 0x192 <can_check_free+0x10>
 19a:	81 e0       	ldi	r24, 0x01	; 1
 19c:	20 ff       	sbrs	r18, 0
 19e:	0d c0       	rjmp	.+26     	; 0x1ba <can_check_free+0x38>
 1a0:	80 e0       	ldi	r24, 0x00	; 0
 1a2:	08 95       	ret


		} else {
		
		mob_status = !((CANEN2 >> mobnum) &1);
 1a4:	20 91 dc 00 	lds	r18, 0x00DC	; 0x8000dc <__TEXT_REGION_LENGTH__+0x7e00dc>
 1a8:	30 e0       	ldi	r19, 0x00	; 0
 1aa:	02 c0       	rjmp	.+4      	; 0x1b0 <can_check_free+0x2e>
 1ac:	35 95       	asr	r19
 1ae:	27 95       	ror	r18
 1b0:	8a 95       	dec	r24
 1b2:	e2 f7       	brpl	.-8      	; 0x1ac <can_check_free+0x2a>
 1b4:	81 e0       	ldi	r24, 0x01	; 1
 1b6:	20 fd       	sbrc	r18, 0
 1b8:	80 e0       	ldi	r24, 0x00	; 0
	}

	return mob_status;
	
}
 1ba:	08 95       	ret

000001bc <can_cfg>:
void can_cfg(){
	
	CANGCON = 0; // Disable CAN
 1bc:	10 92 d8 00 	sts	0x00D8, r1	; 0x8000d8 <__TEXT_REGION_LENGTH__+0x7e00d8>
	
	for (uint8_t mob = 0; mob < 15 ; mob++){//reset all mobs
 1c0:	40 e0       	ldi	r20, 0x00	; 0
 1c2:	29 c0       	rjmp	.+82     	; 0x216 <can_cfg+0x5a>
		CANPAGE = mob<<MOBNB0 | (1<<AINC);
 1c4:	80 e1       	ldi	r24, 0x10	; 16
 1c6:	48 9f       	mul	r20, r24
 1c8:	90 01       	movw	r18, r0
 1ca:	11 24       	eor	r1, r1
 1cc:	82 2f       	mov	r24, r18
 1ce:	88 60       	ori	r24, 0x08	; 8
 1d0:	80 93 ed 00 	sts	0x00ED, r24	; 0x8000ed <__TEXT_REGION_LENGTH__+0x7e00ed>
		CANSTMOB = 0;
 1d4:	10 92 ee 00 	sts	0x00EE, r1	; 0x8000ee <__TEXT_REGION_LENGTH__+0x7e00ee>
		CANCDMOB = 0;
 1d8:	10 92 ef 00 	sts	0x00EF, r1	; 0x8000ef <__TEXT_REGION_LENGTH__+0x7e00ef>
		CANIDT4 = 0;
 1dc:	10 92 f0 00 	sts	0x00F0, r1	; 0x8000f0 <__TEXT_REGION_LENGTH__+0x7e00f0>
		CANIDT3 = 0;
 1e0:	10 92 f1 00 	sts	0x00F1, r1	; 0x8000f1 <__TEXT_REGION_LENGTH__+0x7e00f1>
		CANIDT2 = 0;
 1e4:	10 92 f2 00 	sts	0x00F2, r1	; 0x8000f2 <__TEXT_REGION_LENGTH__+0x7e00f2>
		CANIDT1 = 0;
 1e8:	10 92 f3 00 	sts	0x00F3, r1	; 0x8000f3 <__TEXT_REGION_LENGTH__+0x7e00f3>
		CANIDM4 = 0;
 1ec:	10 92 f4 00 	sts	0x00F4, r1	; 0x8000f4 <__TEXT_REGION_LENGTH__+0x7e00f4>
		CANIDM3 = 0;
 1f0:	10 92 f5 00 	sts	0x00F5, r1	; 0x8000f5 <__TEXT_REGION_LENGTH__+0x7e00f5>
		CANIDM2 = 0;
 1f4:	10 92 f6 00 	sts	0x00F6, r1	; 0x8000f6 <__TEXT_REGION_LENGTH__+0x7e00f6>
		CANIDM1 = 0;
 1f8:	10 92 f7 00 	sts	0x00F7, r1	; 0x8000f7 <__TEXT_REGION_LENGTH__+0x7e00f7>
		for (uint8_t byte = 0; byte < 8; byte++){
 1fc:	80 e0       	ldi	r24, 0x00	; 0
 1fe:	08 c0       	rjmp	.+16     	; 0x210 <can_cfg+0x54>
			CANPAGE = mob<<MOBNB0 | 1<<AINC | byte;
 200:	98 2f       	mov	r25, r24
 202:	92 2b       	or	r25, r18
 204:	98 60       	ori	r25, 0x08	; 8
 206:	90 93 ed 00 	sts	0x00ED, r25	; 0x8000ed <__TEXT_REGION_LENGTH__+0x7e00ed>
			CANMSG = 0;
 20a:	10 92 fa 00 	sts	0x00FA, r1	; 0x8000fa <__TEXT_REGION_LENGTH__+0x7e00fa>
		CANIDT1 = 0;
		CANIDM4 = 0;
		CANIDM3 = 0;
		CANIDM2 = 0;
		CANIDM1 = 0;
		for (uint8_t byte = 0; byte < 8; byte++){
 20e:	8f 5f       	subi	r24, 0xFF	; 255
 210:	88 30       	cpi	r24, 0x08	; 8
 212:	b0 f3       	brcs	.-20     	; 0x200 <can_cfg+0x44>
}
void can_cfg(){
	
	CANGCON = 0; // Disable CAN
	
	for (uint8_t mob = 0; mob < 15 ; mob++){//reset all mobs
 214:	4f 5f       	subi	r20, 0xFF	; 255
 216:	4f 30       	cpi	r20, 0x0F	; 15
 218:	a8 f2       	brcs	.-86     	; 0x1c4 <can_cfg+0x8>
			CANPAGE = mob<<MOBNB0 | 1<<AINC | byte;
			CANMSG = 0;
		}
	}

	CANBT1 = 0x00;// Set Baudrate
 21a:	10 92 e2 00 	sts	0x00E2, r1	; 0x8000e2 <__TEXT_REGION_LENGTH__+0x7e00e2>
	CANBT2 = 0x0C;// 500kBaud according
 21e:	8c e0       	ldi	r24, 0x0C	; 12
 220:	80 93 e3 00 	sts	0x00E3, r24	; 0x8000e3 <__TEXT_REGION_LENGTH__+0x7e00e3>
	CANBT3 = 0x36;// to Datasheet S. 267
 224:	86 e3       	ldi	r24, 0x36	; 54
 226:	80 93 e4 00 	sts	0x00E4, r24	; 0x8000e4 <__TEXT_REGION_LENGTH__+0x7e00e4>

	CANGIE = 0;
 22a:	10 92 db 00 	sts	0x00DB, r1	; 0x8000db <__TEXT_REGION_LENGTH__+0x7e00db>

	CANGCON |= (1<<ENASTB); // Enable CAN
 22e:	e8 ed       	ldi	r30, 0xD8	; 216
 230:	f0 e0       	ldi	r31, 0x00	; 0
 232:	80 81       	ld	r24, Z
 234:	82 60       	ori	r24, 0x02	; 2
 236:	80 83       	st	Z, r24
 238:	08 95       	ret

0000023a <can_rx>:
	
	
	
}
void can_rx(struct CAN_MOB *to_receive, uint8_t *data){
 23a:	0f 93       	push	r16
 23c:	1f 93       	push	r17
 23e:	cf 93       	push	r28
 240:	df 93       	push	r29
 242:	ec 01       	movw	r28, r24
 244:	8b 01       	movw	r16, r22
	
	CANPAGE = to_receive->mob_number << MOBNB0;
 246:	8c 81       	ldd	r24, Y+4	; 0x04
 248:	82 95       	swap	r24
 24a:	80 7f       	andi	r24, 0xF0	; 240
 24c:	80 93 ed 00 	sts	0x00ED, r24	; 0x8000ed <__TEXT_REGION_LENGTH__+0x7e00ed>
	if (can_check_free(to_receive->mob_number)){
 250:	8c 81       	ldd	r24, Y+4	; 0x04
 252:	97 df       	rcall	.-210    	; 0x182 <can_check_free>
 254:	88 23       	and	r24, r24
 256:	71 f1       	breq	.+92     	; 0x2b4 <can_rx+0x7a>
		/* load the id 11 bit */
		CANIDT1 = to_receive->mob_id >>3;
 258:	88 81       	ld	r24, Y
 25a:	99 81       	ldd	r25, Y+1	; 0x01
 25c:	96 95       	lsr	r25
 25e:	87 95       	ror	r24
 260:	96 95       	lsr	r25
 262:	87 95       	ror	r24
 264:	96 95       	lsr	r25
 266:	87 95       	ror	r24
 268:	80 93 f3 00 	sts	0x00F3, r24	; 0x8000f3 <__TEXT_REGION_LENGTH__+0x7e00f3>
		CANIDT2 = (to_receive->mob_id << 5)&0b11100000;
 26c:	88 81       	ld	r24, Y
 26e:	82 95       	swap	r24
 270:	88 0f       	add	r24, r24
 272:	80 7e       	andi	r24, 0xE0	; 224
 274:	80 93 f2 00 	sts	0x00F2, r24	; 0x8000f2 <__TEXT_REGION_LENGTH__+0x7e00f2>
		CANIDT3 = 0;
 278:	10 92 f1 00 	sts	0x00F1, r1	; 0x8000f1 <__TEXT_REGION_LENGTH__+0x7e00f1>
		CANIDT4 = 1<<RTRTAG;
 27c:	84 e0       	ldi	r24, 0x04	; 4
 27e:	80 93 f0 00 	sts	0x00F0, r24	; 0x8000f0 <__TEXT_REGION_LENGTH__+0x7e00f0>
		CANIDM1 = to_receive->mob_idmask >>3;
 282:	8a 81       	ldd	r24, Y+2	; 0x02
 284:	9b 81       	ldd	r25, Y+3	; 0x03
 286:	96 95       	lsr	r25
 288:	87 95       	ror	r24
 28a:	96 95       	lsr	r25
 28c:	87 95       	ror	r24
 28e:	96 95       	lsr	r25
 290:	87 95       	ror	r24
 292:	80 93 f7 00 	sts	0x00F7, r24	; 0x8000f7 <__TEXT_REGION_LENGTH__+0x7e00f7>
		CANIDM2 = (to_receive->mob_idmask <<5)&0b11100000;
 296:	8a 81       	ldd	r24, Y+2	; 0x02
 298:	82 95       	swap	r24
 29a:	88 0f       	add	r24, r24
 29c:	80 7e       	andi	r24, 0xE0	; 224
 29e:	80 93 f6 00 	sts	0x00F6, r24	; 0x8000f6 <__TEXT_REGION_LENGTH__+0x7e00f6>
		CANIDM3 = 0;
 2a2:	10 92 f5 00 	sts	0x00F5, r1	; 0x8000f5 <__TEXT_REGION_LENGTH__+0x7e00f5>
		CANIDM4 = 0;
 2a6:	10 92 f4 00 	sts	0x00F4, r1	; 0x8000f4 <__TEXT_REGION_LENGTH__+0x7e00f4>
		CANCDMOB = (1 << CONMOB1) | (1 << CONMOB0)| (1<<DLC3);
 2aa:	88 ec       	ldi	r24, 0xC8	; 200
 2ac:	80 93 ef 00 	sts	0x00EF, r24	; 0x8000ef <__TEXT_REGION_LENGTH__+0x7e00ef>
		CANSTMOB = 0;
 2b0:	10 92 ee 00 	sts	0x00EE, r1	; 0x8000ee <__TEXT_REGION_LENGTH__+0x7e00ee>
	CANGCON |= (1<<ENASTB); // Enable CAN
	
	
	
}
void can_rx(struct CAN_MOB *to_receive, uint8_t *data){
 2b4:	20 e0       	ldi	r18, 0x00	; 0
 2b6:	10 c0       	rjmp	.+32     	; 0x2d8 <can_rx+0x9e>
		CANCDMOB = (1 << CONMOB1) | (1 << CONMOB0)| (1<<DLC3);
		CANSTMOB = 0;
	}
	
	for(uint8_t byte = 0; byte <8; byte++){
		CANPAGE = (to_receive->mob_number << MOBNB0) | (1 << AINC) | byte;
 2b8:	8c 81       	ldd	r24, Y+4	; 0x04
 2ba:	30 e1       	ldi	r19, 0x10	; 16
 2bc:	83 9f       	mul	r24, r19
 2be:	c0 01       	movw	r24, r0
 2c0:	11 24       	eor	r1, r1
 2c2:	82 2b       	or	r24, r18
 2c4:	88 60       	ori	r24, 0x08	; 8
 2c6:	80 93 ed 00 	sts	0x00ED, r24	; 0x8000ed <__TEXT_REGION_LENGTH__+0x7e00ed>
		data[byte] = CANMSG;
 2ca:	f8 01       	movw	r30, r16
 2cc:	e2 0f       	add	r30, r18
 2ce:	f1 1d       	adc	r31, r1
 2d0:	80 91 fa 00 	lds	r24, 0x00FA	; 0x8000fa <__TEXT_REGION_LENGTH__+0x7e00fa>
 2d4:	80 83       	st	Z, r24
		CANIDM4 = 0;
		CANCDMOB = (1 << CONMOB1) | (1 << CONMOB0)| (1<<DLC3);
		CANSTMOB = 0;
	}
	
	for(uint8_t byte = 0; byte <8; byte++){
 2d6:	2f 5f       	subi	r18, 0xFF	; 255
 2d8:	28 30       	cpi	r18, 0x08	; 8
 2da:	70 f3       	brcs	.-36     	; 0x2b8 <can_rx+0x7e>
		CANPAGE = (to_receive->mob_number << MOBNB0) | (1 << AINC) | byte;
		data[byte] = CANMSG;
	}
	
	
}
 2dc:	df 91       	pop	r29
 2de:	cf 91       	pop	r28
 2e0:	1f 91       	pop	r17
 2e2:	0f 91       	pop	r16
 2e4:	08 95       	ret

000002e6 <can_tx>:
void can_tx(struct CAN_MOB *to_send, uint8_t *data){
 2e6:	cf 93       	push	r28
 2e8:	df 93       	push	r29
 2ea:	ec 01       	movw	r28, r24
	
	for(uint8_t byte = 0; byte <8; byte++){
 2ec:	20 e0       	ldi	r18, 0x00	; 0
 2ee:	10 c0       	rjmp	.+32     	; 0x310 <can_tx+0x2a>
		CANPAGE = (to_send->mob_number << MOBNB0) | (1 << AINC) | byte;
 2f0:	8c 81       	ldd	r24, Y+4	; 0x04
 2f2:	30 e1       	ldi	r19, 0x10	; 16
 2f4:	83 9f       	mul	r24, r19
 2f6:	c0 01       	movw	r24, r0
 2f8:	11 24       	eor	r1, r1
 2fa:	82 2b       	or	r24, r18
 2fc:	88 60       	ori	r24, 0x08	; 8
 2fe:	80 93 ed 00 	sts	0x00ED, r24	; 0x8000ed <__TEXT_REGION_LENGTH__+0x7e00ed>
		CANMSG = data[byte];
 302:	fb 01       	movw	r30, r22
 304:	e2 0f       	add	r30, r18
 306:	f1 1d       	adc	r31, r1
 308:	80 81       	ld	r24, Z
 30a:	80 93 fa 00 	sts	0x00FA, r24	; 0x8000fa <__TEXT_REGION_LENGTH__+0x7e00fa>
	
	
}
void can_tx(struct CAN_MOB *to_send, uint8_t *data){
	
	for(uint8_t byte = 0; byte <8; byte++){
 30e:	2f 5f       	subi	r18, 0xFF	; 255
 310:	28 30       	cpi	r18, 0x08	; 8
 312:	70 f3       	brcs	.-36     	; 0x2f0 <can_tx+0xa>
		CANPAGE = (to_send->mob_number << MOBNB0) | (1 << AINC) | byte;
		CANMSG = data[byte];
	}
	
	CANPAGE = to_send->mob_number << MOBNB0;
 314:	8c 81       	ldd	r24, Y+4	; 0x04
 316:	82 95       	swap	r24
 318:	80 7f       	andi	r24, 0xF0	; 240
 31a:	80 93 ed 00 	sts	0x00ED, r24	; 0x8000ed <__TEXT_REGION_LENGTH__+0x7e00ed>
	if (can_check_free(to_send->mob_number)){
 31e:	8c 81       	ldd	r24, Y+4	; 0x04
 320:	30 df       	rcall	.-416    	; 0x182 <can_check_free>
 322:	88 23       	and	r24, r24
 324:	21 f1       	breq	.+72     	; 0x36e <can_tx+0x88>
		CANSTMOB = 0;
 326:	ee ee       	ldi	r30, 0xEE	; 238
 328:	f0 e0       	ldi	r31, 0x00	; 0
 32a:	10 82       	st	Z, r1
		CANIDT1 = to_send->mob_id>>3;
 32c:	88 81       	ld	r24, Y
 32e:	99 81       	ldd	r25, Y+1	; 0x01
 330:	96 95       	lsr	r25
 332:	87 95       	ror	r24
 334:	96 95       	lsr	r25
 336:	87 95       	ror	r24
 338:	96 95       	lsr	r25
 33a:	87 95       	ror	r24
 33c:	80 93 f3 00 	sts	0x00F3, r24	; 0x8000f3 <__TEXT_REGION_LENGTH__+0x7e00f3>
		CANIDT2 = (to_send->mob_id << 5) & 0b11100000;
 340:	88 81       	ld	r24, Y
 342:	82 95       	swap	r24
 344:	88 0f       	add	r24, r24
 346:	80 7e       	andi	r24, 0xE0	; 224
 348:	80 93 f2 00 	sts	0x00F2, r24	; 0x8000f2 <__TEXT_REGION_LENGTH__+0x7e00f2>
		CANIDT3 = 0;
 34c:	10 92 f1 00 	sts	0x00F1, r1	; 0x8000f1 <__TEXT_REGION_LENGTH__+0x7e00f1>
		CANIDT4 = 0;
 350:	10 92 f0 00 	sts	0x00F0, r1	; 0x8000f0 <__TEXT_REGION_LENGTH__+0x7e00f0>
		CANIDM1 = 0; //0b11111111;
 354:	10 92 f7 00 	sts	0x00F7, r1	; 0x8000f7 <__TEXT_REGION_LENGTH__+0x7e00f7>
		CANIDM2 = 0; //0b11100000;
 358:	10 92 f6 00 	sts	0x00F6, r1	; 0x8000f6 <__TEXT_REGION_LENGTH__+0x7e00f6>
		CANIDM3 = 0;
 35c:	10 92 f5 00 	sts	0x00F5, r1	; 0x8000f5 <__TEXT_REGION_LENGTH__+0x7e00f5>
		CANIDM4 = 0;
 360:	10 92 f4 00 	sts	0x00F4, r1	; 0x8000f4 <__TEXT_REGION_LENGTH__+0x7e00f4>
		CANSTMOB = 0;
 364:	10 82       	st	Z, r1
		CANCDMOB = (1<<CONMOB0) | 1 << DLC3;
 366:	88 e4       	ldi	r24, 0x48	; 72
 368:	80 93 ef 00 	sts	0x00EF, r24	; 0x8000ef <__TEXT_REGION_LENGTH__+0x7e00ef>
		CANSTMOB = 0;
 36c:	10 82       	st	Z, r1
	}
	
}
 36e:	df 91       	pop	r29
 370:	cf 91       	pop	r28
 372:	08 95       	ret

00000374 <fan_power_unit_PWM_control>:
#include <avr/interrupt.h>
#include "fan_power_unit_PWM_control.h"

volatile uint8_t fan_duty = 1;		

void fan_power_unit_PWM_control(uint8_t temperature, uint8_t fan_duty){	
 374:	08 95       	ret

00000376 <timer1_config>:
		fan_duty = (temperature*63)/100;
	}	
}

void timer1_config(){	
DDRB |= (1<<PB6);			// setting COM1nx Bits not necessary because we can also toggle/set pins using the ISR, here the Fan PWM cable is already on the Pin toggle by those bits												
 376:	84 b1       	in	r24, 0x04	; 4
 378:	80 64       	ori	r24, 0x40	; 64
 37a:	84 b9       	out	0x04, r24	; 4
TCCR1A = (1<<WGM11) | (1<<WGM10) | (0<<COM1A1) | (1<<COM1A0) | (1<<COM1B1);	//mode 15, prescaler 8, non inverted mode => page 138 - 139  
 37c:	83 e6       	ldi	r24, 0x63	; 99
 37e:	80 93 80 00 	sts	0x0080, r24	; 0x800080 <__TEXT_REGION_LENGTH__+0x7e0080>
TCCR1B = (1<<WGM13) | (1<<WGM12) | (1<<CS11);								// Fast PWM description => page 128
 382:	8a e1       	ldi	r24, 0x1A	; 26
 384:	80 93 81 00 	sts	0x0081, r24	; 0x800081 <__TEXT_REGION_LENGTH__+0x7e0081>
TIMSK1 = (1<<OCIE1A);														//Output Compare interrupt flag will be set whenever OCR1A is reached
 388:	82 e0       	ldi	r24, 0x02	; 2
 38a:	80 93 6f 00 	sts	0x006F, r24	; 0x80006f <__TEXT_REGION_LENGTH__+0x7e006f>
OCR1A = 63;													// TOP  16000000/(8*(1+64)) = 30769.23077 Hz = ~30kHz => page 130   with TOP value 62+1 the resolution is 6 bit => page 128
 38e:	8f e3       	ldi	r24, 0x3F	; 63
 390:	90 e0       	ldi	r25, 0x00	; 0
 392:	90 93 89 00 	sts	0x0089, r25	; 0x800089 <__TEXT_REGION_LENGTH__+0x7e0089>
 396:	80 93 88 00 	sts	0x0088, r24	; 0x800088 <__TEXT_REGION_LENGTH__+0x7e0088>
OCR1B = 10;													// BOTTOM
 39a:	8a e0       	ldi	r24, 0x0A	; 10
 39c:	90 e0       	ldi	r25, 0x00	; 0
 39e:	90 93 8b 00 	sts	0x008B, r25	; 0x80008b <__TEXT_REGION_LENGTH__+0x7e008b>
 3a2:	80 93 8a 00 	sts	0x008A, r24	; 0x80008a <__TEXT_REGION_LENGTH__+0x7e008a>
 3a6:	08 95       	ret

000003a8 <__vector_12>:
}

ISR(TIMER1_COMPA_vect){									//ISR for the timer 1, updating the duty cycle
 3a8:	1f 92       	push	r1
 3aa:	0f 92       	push	r0
 3ac:	0f b6       	in	r0, 0x3f	; 63
 3ae:	0f 92       	push	r0
 3b0:	11 24       	eor	r1, r1
 3b2:	8f 93       	push	r24
 3b4:	9f 93       	push	r25
OCR1B = fan_duty;
 3b6:	80 91 00 01 	lds	r24, 0x0100	; 0x800100 <__DATA_REGION_ORIGIN__>
 3ba:	90 e0       	ldi	r25, 0x00	; 0
 3bc:	90 93 8b 00 	sts	0x008B, r25	; 0x80008b <__TEXT_REGION_LENGTH__+0x7e008b>
 3c0:	80 93 8a 00 	sts	0x008A, r24	; 0x80008a <__TEXT_REGION_LENGTH__+0x7e008a>
 3c4:	9f 91       	pop	r25
 3c6:	8f 91       	pop	r24
 3c8:	0f 90       	pop	r0
 3ca:	0f be       	out	0x3f, r0	; 63
 3cc:	0f 90       	pop	r0
 3ce:	1f 90       	pop	r1
 3d0:	18 95       	reti

000003d2 <main>:
extern volatile unsigned long r2d_length;

extern volatile uint8_t fan_duty;
uint8_t R2D_pressed = 0;

int main(void){
 3d2:	cf 93       	push	r28
 3d4:	df 93       	push	r29
 3d6:	cd b7       	in	r28, 0x3d	; 61
 3d8:	de b7       	in	r29, 0x3e	; 62
 3da:	6a 97       	sbiw	r28, 0x1a	; 26
 3dc:	0f b6       	in	r0, 0x3f	; 63
 3de:	f8 94       	cli
 3e0:	de bf       	out	0x3e, r29	; 62
 3e2:	0f be       	out	0x3f, r0	; 63
 3e4:	cd bf       	out	0x3d, r28	; 61
sys_timer_config();
 3e6:	ee d0       	rcall	.+476    	; 0x5c4 <sys_timer_config>
port_config();
 3e8:	e4 d0       	rcall	.+456    	; 0x5b2 <port_config>
can_cfg();
 3ea:	e8 de       	rcall	.-560    	; 0x1bc <can_cfg>
adc_config();
 3ec:	71 de       	rcall	.-798    	; 0xd0 <adc_config>
 3ee:	2a d1       	rcall	.+596    	; 0x644 <timer2_config>
timer2_config();
 3f0:	c2 df       	rcall	.-124    	; 0x376 <timer1_config>
 3f2:	1a 82       	std	Y+2, r1	; 0x02
timer1_config();
 3f4:	19 82       	std	Y+1, r1	; 0x01
 3f6:	1c 82       	std	Y+4, r1	; 0x04
	
struct CAN_MOB can_FB_mob;//data to send  FB = fusebox, outgoing fusebox message with its 8 dataBYTES
can_FB_mob.mob_id = 0;
 3f8:	1b 82       	std	Y+3, r1	; 0x03
 3fa:	1d 82       	std	Y+5, r1	; 0x05
can_FB_mob.mob_idmask = 0;
 3fc:	80 e0       	ldi	r24, 0x00	; 0
 3fe:	91 e0       	ldi	r25, 0x01	; 1
can_FB_mob.mob_number = 0;
 400:	9f 87       	std	Y+15, r25	; 0x0f
uint8_t FB_databytes[8];  

struct CAN_MOB can_R2D_mob;
can_R2D_mob.mob_id = 0b100000000;
 402:	8e 87       	std	Y+14, r24	; 0x0e
 404:	8f ef       	ldi	r24, 0xFF	; 255
 406:	97 e0       	ldi	r25, 0x07	; 7
 408:	99 8b       	std	Y+17, r25	; 0x11
can_R2D_mob.mob_idmask = 0b11111111111;
 40a:	88 8b       	std	Y+16, r24	; 0x10
 40c:	1a 8a       	std	Y+18, r1	; 0x12
 40e:	78 94       	sei
 410:	80 91 16 01 	lds	r24, 0x0116	; 0x800116 <sys_time>
can_R2D_mob.mob_number = 0;
uint8_t R2D_databytes[8];
	
sei();
 414:	90 91 17 01 	lds	r25, 0x0117	; 0x800117 <sys_time+0x1>
	
	while (1){
		if(/*(sys_time - time_old) > 10*/TIME_PASSED_10_MS){  //10ms  //define 10_MS_PASSED ((sys_time - time_old) > 10)
 418:	a0 91 18 01 	lds	r26, 0x0118	; 0x800118 <sys_time+0x2>
 41c:	b0 91 19 01 	lds	r27, 0x0119	; 0x800119 <sys_time+0x3>
 420:	40 91 12 01 	lds	r20, 0x0112	; 0x800112 <time_old>
 424:	50 91 13 01 	lds	r21, 0x0113	; 0x800113 <time_old+0x1>
 428:	60 91 14 01 	lds	r22, 0x0114	; 0x800114 <time_old+0x2>
 42c:	70 91 15 01 	lds	r23, 0x0115	; 0x800115 <time_old+0x3>
 430:	8c 01       	movw	r16, r24
 432:	9d 01       	movw	r18, r26
 434:	04 1b       	sub	r16, r20
 436:	15 0b       	sbc	r17, r21
 438:	26 0b       	sbc	r18, r22
 43a:	37 0b       	sbc	r19, r23
 43c:	0b 30       	cpi	r16, 0x0B	; 11
 43e:	11 05       	cpc	r17, r1
 440:	21 05       	cpc	r18, r1
 442:	31 05       	cpc	r19, r1
 444:	08 f4       	brcc	.+2      	; 0x448 <__LOCK_REGION_LENGTH__+0x48>
 446:	99 c0       	rjmp	.+306    	; 0x57a <__LOCK_REGION_LENGTH__+0x17a>
 448:	80 93 12 01 	sts	0x0112, r24	; 0x800112 <time_old>
 44c:	90 93 13 01 	sts	0x0113, r25	; 0x800113 <time_old+0x1>
			time_old = sys_time; 
 450:	a0 93 14 01 	sts	0x0114, r26	; 0x800114 <time_old+0x2>
 454:	b0 93 15 01 	sts	0x0115, r27	; 0x800115 <time_old+0x3>
 458:	80 91 0e 01 	lds	r24, 0x010E	; 0x80010e <time_old_100ms>
 45c:	90 91 0f 01 	lds	r25, 0x010F	; 0x80010f <time_old_100ms+0x1>
			time_old_100ms++;   //FIND BETTER NAME, WHY OLD??
 460:	a0 91 10 01 	lds	r26, 0x0110	; 0x800110 <time_old_100ms+0x2>
 464:	b0 91 11 01 	lds	r27, 0x0111	; 0x800111 <time_old_100ms+0x3>
 468:	01 96       	adiw	r24, 0x01	; 1
 46a:	a1 1d       	adc	r26, r1
 46c:	b1 1d       	adc	r27, r1
 46e:	80 93 0e 01 	sts	0x010E, r24	; 0x80010e <time_old_100ms>
 472:	90 93 0f 01 	sts	0x010F, r25	; 0x80010f <time_old_100ms+0x1>
 476:	a0 93 10 01 	sts	0x0110, r26	; 0x800110 <time_old_100ms+0x2>
 47a:	b0 93 11 01 	sts	0x0111, r27	; 0x800111 <time_old_100ms+0x3>
 47e:	2c b1       	in	r18, 0x0c	; 12
 480:	80 b1       	in	r24, 0x00	; 0
 482:	90 e0       	ldi	r25, 0x00	; 0
// 		if((sys_time - sys_time_old) >= 1){
// 			sys_time_old = sys_time;   //MAYBE USE THIS AS FIRST TIMER AND THE BUILD THE 10 and 100 ONES ON TOP OF IT?
// 			time_X_ms++;
// 		}
// after this add any timers time_10_ms, time_20_ms ...
			if (FUSES_ALL_IN){ //fuses in,   0b0000111111111111  	
 484:	98 2f       	mov	r25, r24
 486:	88 27       	eor	r24, r24
 488:	9f 70       	andi	r25, 0x0F	; 15
 48a:	82 2b       	or	r24, r18
 48c:	8f 3f       	cpi	r24, 0xFF	; 255
 48e:	9f 40       	sbci	r25, 0x0F	; 15
 490:	11 f4       	brne	.+4      	; 0x496 <__LOCK_REGION_LENGTH__+0x96>
 492:	d0 d0       	rcall	.+416    	; 0x634 <fault_not_detected>
				fault_not_detected();																					
 494:	01 c0       	rjmp	.+2      	; 0x498 <__LOCK_REGION_LENGTH__+0x98>
 496:	d2 d0       	rcall	.+420    	; 0x63c <fault_detected>
 498:	80 b1       	in	r24, 0x00	; 0
			}																															
			else{
				fault_detected();	
 49a:	8c b1       	in	r24, 0x0c	; 12
 49c:	8e 83       	std	Y+6, r24	; 0x06
			} 
						
//fuse_read_out()&0xff;			// input &0xff gives you the first byte (8bit) (least significant byte)
//(fuse_read_out()>>8)&0xff;		//shifting 1 byte to the right gives us the next 8 bit bundle, now we've read the full 16 bit value

 			FB_databytes[0]	= fuse_read_out()&0xff		;			//  lsb  //define FUSES_LEAST_SIGNIFICANT_BITS
 49e:	9c b1       	in	r25, 0x0c	; 12
 4a0:	80 b1       	in	r24, 0x00	; 0
			FB_databytes[1]	= (fuse_read_out()>>8)&0xff	;			//  msb		//define FUSES_MOST_SIGNIFICANT_BITS
 4a2:	89 2b       	or	r24, r25
 4a4:	8f 83       	std	Y+7, r24	; 0x07
 4a6:	86 b1       	in	r24, 0x06	; 6
 			FB_databytes[2]	= SCI_read_out()			;			// fits in 8 bits  //MAYBE NO DEFINE MACROS NEEDED?
 4a8:	88 87       	std	Y+8, r24	; 0x08
 			FB_databytes[3]	= /*adc_get(0)*/ adc_get(0)&0xff;//this is more than 8 bit (around 575) 
 4aa:	80 e0       	ldi	r24, 0x00	; 0
 4ac:	61 de       	rcall	.-830    	; 0x170 <adc_get>
 4ae:	89 87       	std	Y+9, r24	; 0x09
			FB_databytes[4]	= /*adc_get(1)*/ (adc_get(0)>>8)&0xff;  //this is more than 8 bit (around 770) both estimates for 21.0V supply ONLY
 4b0:	80 e0       	ldi	r24, 0x00	; 0
 4b2:	5e de       	rcall	.-836    	; 0x170 <adc_get>
 4b4:	9a 87       	std	Y+10, r25	; 0x0a
 4b6:	81 e0       	ldi	r24, 0x01	; 1
			FB_databytes[5] = adc_get(1)&0xff			;
 4b8:	5b de       	rcall	.-842    	; 0x170 <adc_get>
 4ba:	8b 87       	std	Y+11, r24	; 0x0b
 4bc:	81 e0       	ldi	r24, 0x01	; 1
 			FB_databytes[6]	= (adc_get(1)>>8)&0xff		;
 4be:	58 de       	rcall	.-848    	; 0x170 <adc_get>
 4c0:	9c 87       	std	Y+12, r25	; 0x0c
 4c2:	1d 86       	std	Y+13, r1	; 0x0d
 4c4:	be 01       	movw	r22, r28
			FB_databytes[7]	= 0							;

 			can_tx(&can_FB_mob, FB_databytes);  //& is a reference operator 
 4c6:	6a 5f       	subi	r22, 0xFA	; 250
 4c8:	7f 4f       	sbci	r23, 0xFF	; 255
 4ca:	ce 01       	movw	r24, r28
 4cc:	01 96       	adiw	r24, 0x01	; 1
 4ce:	0b df       	rcall	.-490    	; 0x2e6 <can_tx>
 4d0:	be 01       	movw	r22, r28
 4d2:	6d 5e       	subi	r22, 0xED	; 237
			can_rx(&can_R2D_mob, R2D_databytes);
 4d4:	7f 4f       	sbci	r23, 0xFF	; 255
 4d6:	ce 01       	movw	r24, r28
 4d8:	0e 96       	adiw	r24, 0x0e	; 14
 4da:	af de       	rcall	.-674    	; 0x23a <can_rx>
 4dc:	8d 89       	ldd	r24, Y+21	; 0x15
 4de:	80 93 0d 01 	sts	0x010D, r24	; 0x80010d <R2D_pressed>
		
			R2D_pressed = R2D_databytes[2];// | R2D_databytes[3];
 4e2:	2c b1       	in	r18, 0x0c	; 12
 4e4:	80 b1       	in	r24, 0x00	; 0
 4e6:	90 e0       	ldi	r25, 0x00	; 0
	
			if ((fuse_read_out() & 0xFFF) < 0xFFF){  //debugging purposes fuse acts as my switch, NO MACRO NOW THE 3 CONDITIONS COME HERE: READY TO DRIVE, POWER ON and BUTTON PRESSED?
 4e8:	98 2f       	mov	r25, r24
 4ea:	88 27       	eor	r24, r24
 4ec:	9f 70       	andi	r25, 0x0F	; 15
 4ee:	82 2b       	or	r24, r18
 4f0:	8f 3f       	cpi	r24, 0xFF	; 255
 4f2:	9f 40       	sbci	r25, 0x0F	; 15
 4f4:	28 f4       	brcc	.+10     	; 0x500 <__LOCK_REGION_LENGTH__+0x100>
 4f6:	e0 eb       	ldi	r30, 0xB0	; 176
 4f8:	f0 e0       	ldi	r31, 0x00	; 0
 4fa:	80 81       	ld	r24, Z
 					START_TIMER_2; /*TCCR2A |= (1<<CS22);*/ // starts timer //use defines to just have a START TIMER thingy => no commenting needed						
 4fc:	84 60       	ori	r24, 0x04	; 4
 4fe:	80 83       	st	Z, r24
 500:	80 91 1c 01 	lds	r24, 0x011C	; 0x80011c <r2d_length>
 504:	90 91 1d 01 	lds	r25, 0x011D	; 0x80011d <r2d_length+0x1>
			}    //define START_TIMER_2

	
			if (r2d_length < 23000){ // under 3 seconds as long as the button is not held longer than a singular press => will lead into a 2nd cycle starting 
 508:	a0 91 1e 01 	lds	r26, 0x011E	; 0x80011e <r2d_length+0x2>
 50c:	b0 91 1f 01 	lds	r27, 0x011F	; 0x80011f <r2d_length+0x3>
 510:	88 3d       	cpi	r24, 0xD8	; 216
 512:	99 45       	sbci	r25, 0x59	; 89
 514:	a1 05       	cpc	r26, r1
 516:	b1 05       	cpc	r27, r1
 518:	a0 f4       	brcc	.+40     	; 0x542 <__LOCK_REGION_LENGTH__+0x142>
 51a:	80 91 1b 01 	lds	r24, 0x011B	; 0x80011b <note_length>
 51e:	8f 5f       	subi	r24, 0xFF	; 255
									//setting the length to 16000 leads to a ~2 sec long sound  (tested with a stopwatch)
				/*OCR2A = song[note_next];*/
				note_length++;
 520:	80 93 1b 01 	sts	0x011B, r24	; 0x80011b <note_length>
 524:	85 30       	cpi	r24, 0x05	; 5
 526:	39 f4       	brne	.+14     	; 0x536 <__LOCK_REGION_LENGTH__+0x136>
 528:	10 92 1b 01 	sts	0x011B, r1	; 0x80011b <note_length>
						//move to ISR !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! 
						// to avoid timing issues!!!!!!!!!!!!!!!!!!!!!!!!!!
						//as of now length is variable and will decrease with decrementing OCR1A values
						//[SOLVED] moved increments to ISR like a normal person 
 				if (note_length == 5){
 52c:	80 91 1a 01 	lds	r24, 0x011A	; 0x80011a <note_next>
				note_length = 0;
 530:	8f 5f       	subi	r24, 0xFF	; 255
 				note_next++;
 532:	80 93 1a 01 	sts	0x011A, r24	; 0x80011a <note_next>
 536:	80 91 1a 01 	lds	r24, 0x011A	; 0x80011a <note_next>
 53a:	8a 30       	cpi	r24, 0x0A	; 10
				}
 				if (note_next == 10){
 53c:	11 f4       	brne	.+4      	; 0x542 <__LOCK_REGION_LENGTH__+0x142>
 53e:	10 92 1a 01 	sts	0x011A, r1	; 0x80011a <note_next>
 542:	80 91 1c 01 	lds	r24, 0x011C	; 0x80011c <r2d_length>
 				note_next = 0;
 546:	90 91 1d 01 	lds	r25, 0x011D	; 0x80011d <r2d_length+0x1>
 				}	
			}	
			if (r2d_length >= 23000){
 54a:	a0 91 1e 01 	lds	r26, 0x011E	; 0x80011e <r2d_length+0x2>
 54e:	b0 91 1f 01 	lds	r27, 0x011F	; 0x80011f <r2d_length+0x3>
 552:	88 3d       	cpi	r24, 0xD8	; 216
 554:	99 45       	sbci	r25, 0x59	; 89
 556:	a1 05       	cpc	r26, r1
 558:	b1 05       	cpc	r27, r1
 55a:	78 f0       	brcs	.+30     	; 0x57a <__LOCK_REGION_LENGTH__+0x17a>
 55c:	e0 eb       	ldi	r30, 0xB0	; 176
 55e:	f0 e0       	ldi	r31, 0x00	; 0
 560:	80 81       	ld	r24, Z
				TCCR2A &= ~(1<<CS22);
 562:	8b 7f       	andi	r24, 0xFB	; 251
 564:	80 83       	st	Z, r24
 566:	10 92 1c 01 	sts	0x011C, r1	; 0x80011c <r2d_length>
 56a:	10 92 1d 01 	sts	0x011D, r1	; 0x80011d <r2d_length+0x1>
				r2d_length = 0;
 56e:	10 92 1e 01 	sts	0x011E, r1	; 0x80011e <r2d_length+0x2>
 572:	10 92 1f 01 	sts	0x011F, r1	; 0x80011f <r2d_length+0x3>
 576:	10 92 1a 01 	sts	0x011A, r1	; 0x80011a <note_next>
 57a:	80 91 0e 01 	lds	r24, 0x010E	; 0x80010e <time_old_100ms>
				note_next = 0;
 57e:	90 91 0f 01 	lds	r25, 0x010F	; 0x80010f <time_old_100ms+0x1>
			}
	
		}	//end of 10 ms cycle
	
		if (/*time_old_100ms >= 100*/TIME_PASSED_100_MS){ //100 ms
 582:	a0 91 10 01 	lds	r26, 0x0110	; 0x800110 <time_old_100ms+0x2>
 586:	b0 91 11 01 	lds	r27, 0x0111	; 0x800111 <time_old_100ms+0x3>
 58a:	84 36       	cpi	r24, 0x64	; 100
 58c:	91 05       	cpc	r25, r1
 58e:	a1 05       	cpc	r26, r1
 590:	b1 05       	cpc	r27, r1
 592:	08 f4       	brcc	.+2      	; 0x596 <__LOCK_REGION_LENGTH__+0x196>
 594:	3d cf       	rjmp	.-390    	; 0x410 <__LOCK_REGION_LENGTH__+0x10>
 596:	10 92 0e 01 	sts	0x010E, r1	; 0x80010e <time_old_100ms>
 			time_old_100ms = 0;
 59a:	10 92 0f 01 	sts	0x010F, r1	; 0x80010f <time_old_100ms+0x1>
 59e:	10 92 10 01 	sts	0x0110, r1	; 0x800110 <time_old_100ms+0x2>
 5a2:	10 92 11 01 	sts	0x0111, r1	; 0x800111 <time_old_100ms+0x3>
 5a6:	1c d0       	rcall	.+56     	; 0x5e0 <sys_tick_heart>
 			sys_tick_heart();
 5a8:	60 91 00 01 	lds	r22, 0x0100	; 0x800100 <__DATA_REGION_ORIGIN__>
 			int16_t x = 50;
 			//for (x = 5; x < 90; x++){  //testing the range of values to alter the duty%
 				int16_t CAN_temperature = x; //from can
 				uint8_t T = (uint8_t) CAN_temperature;
 				//_delay_ms(1);   //use sys timer later
 				fan_power_unit_PWM_control(T, fan_duty);	
 5ac:	82 e3       	ldi	r24, 0x32	; 50
 5ae:	e2 de       	rcall	.-572    	; 0x374 <fan_power_unit_PWM_control>
 5b0:	2f cf       	rjmp	.-418    	; 0x410 <__LOCK_REGION_LENGTH__+0x10>

000005b2 <port_config>:
#include <avr/interrupt.h>

volatile unsigned long sys_time = 0;

void port_config(){  //0 input, 1 output
	DDRA = 0;   //Fuse Read Out Inputs
 5b2:	11 b8       	out	0x01, r1	; 1
	DDRB = 0 | (1<<PB0) |(1<<PB2) | (1<<PB3) | (1<<PB4) | (1<<PB5); //WP, fan and LED outputs
 5b4:	8d e3       	ldi	r24, 0x3D	; 61
 5b6:	84 b9       	out	0x04, r24	; 4
	DDRC = 0; // Shutdown circuit just like FRO is an input 
 5b8:	17 b8       	out	0x07, r1	; 7
	DDRD = 0 | (1<<PD2) | (1<<PD3) | (1<<PD5); /*| (1<<PD6);SET TO 0?*/ // timer for the buzzer and can outputs, PD5 transmits to CAN, PD6 is a receiver
 5ba:	8c e2       	ldi	r24, 0x2C	; 44
 5bc:	8a b9       	out	0x0a, r24	; 10
	DDRE = 0; //Fuse Read Out Inputs
 5be:	1d b8       	out	0x0d, r1	; 13
	DDRF = 0; //JTAG and 2 ADC readings inputs
 5c0:	10 ba       	out	0x10, r1	; 16
 5c2:	08 95       	ret

000005c4 <sys_timer_config>:
}

void sys_timer_config(){  
	TCCR0A |= (1<<WGM01); //CTC mode
 5c4:	84 b5       	in	r24, 0x24	; 36
 5c6:	88 60       	ori	r24, 0x08	; 8
 5c8:	84 bd       	out	0x24, r24	; 36
	TCCR0A |= (1<<CS01) | (1<<CS00); //prescaler 64 => page 111
 5ca:	84 b5       	in	r24, 0x24	; 36
 5cc:	83 60       	ori	r24, 0x03	; 3
 5ce:	84 bd       	out	0x24, r24	; 36
	TIMSK0 |= (1<<OCF0A);  //interrupt flags enable
 5d0:	ee e6       	ldi	r30, 0x6E	; 110
 5d2:	f0 e0       	ldi	r31, 0x00	; 0
 5d4:	80 81       	ld	r24, Z
 5d6:	82 60       	ori	r24, 0x02	; 2
 5d8:	80 83       	st	Z, r24
	OCR0A = 124;  //TOP for 1ms   => 16000000/2*64*(1+124) = 1000 Hz
 5da:	8c e7       	ldi	r24, 0x7C	; 124
 5dc:	87 bd       	out	0x27, r24	; 39
 5de:	08 95       	ret

000005e0 <sys_tick_heart>:
}

void sys_tick_heart(){
	PORTB ^= (1<<PB4); //toggle the Heart led on Pin 4, will be used in the super loop in main.c to indicade that the loop is running correctly	
 5e0:	95 b1       	in	r25, 0x05	; 5
 5e2:	80 e1       	ldi	r24, 0x10	; 16
 5e4:	89 27       	eor	r24, r25
 5e6:	85 b9       	out	0x05, r24	; 5
 5e8:	08 95       	ret

000005ea <__vector_16>:
};

ISR(TIMER0_COMP_vect){
 5ea:	1f 92       	push	r1
 5ec:	0f 92       	push	r0
 5ee:	0f b6       	in	r0, 0x3f	; 63
 5f0:	0f 92       	push	r0
 5f2:	11 24       	eor	r1, r1
 5f4:	8f 93       	push	r24
 5f6:	9f 93       	push	r25
 5f8:	af 93       	push	r26
 5fa:	bf 93       	push	r27
	sys_time++;  //system time incremented on each interrupt flag from the CTC mode compare register => every OCR0A
 5fc:	80 91 16 01 	lds	r24, 0x0116	; 0x800116 <sys_time>
 600:	90 91 17 01 	lds	r25, 0x0117	; 0x800117 <sys_time+0x1>
 604:	a0 91 18 01 	lds	r26, 0x0118	; 0x800118 <sys_time+0x2>
 608:	b0 91 19 01 	lds	r27, 0x0119	; 0x800119 <sys_time+0x3>
 60c:	01 96       	adiw	r24, 0x01	; 1
 60e:	a1 1d       	adc	r26, r1
 610:	b1 1d       	adc	r27, r1
 612:	80 93 16 01 	sts	0x0116, r24	; 0x800116 <sys_time>
 616:	90 93 17 01 	sts	0x0117, r25	; 0x800117 <sys_time+0x1>
 61a:	a0 93 18 01 	sts	0x0118, r26	; 0x800118 <sys_time+0x2>
 61e:	b0 93 19 01 	sts	0x0119, r27	; 0x800119 <sys_time+0x3>
}
 622:	bf 91       	pop	r27
 624:	af 91       	pop	r26
 626:	9f 91       	pop	r25
 628:	8f 91       	pop	r24
 62a:	0f 90       	pop	r0
 62c:	0f be       	out	0x3f, r0	; 63
 62e:	0f 90       	pop	r0
 630:	1f 90       	pop	r1
 632:	18 95       	reti

00000634 <fault_not_detected>:

void fault_not_detected(){	
	PORTB &= ~(1<<PB3); //turn off red led in case of no fault
 634:	85 b1       	in	r24, 0x05	; 5
 636:	87 7f       	andi	r24, 0xF7	; 247
 638:	85 b9       	out	0x05, r24	; 5
 63a:	08 95       	ret

0000063c <fault_detected>:
}
void fault_detected(){
	PORTB |= (1<<PB3); //turn on red led when called (fault present)
 63c:	85 b1       	in	r24, 0x05	; 5
 63e:	88 60       	ori	r24, 0x08	; 8
 640:	85 b9       	out	0x05, r24	; 5
 642:	08 95       	ret

00000644 <timer2_config>:
		if (note_length == 5){
			note_length = 0;
			note_next++;
		}
		if (note_next == 10){
			note_next = 0;
 644:	e0 eb       	ldi	r30, 0xB0	; 176
 646:	f0 e0       	ldi	r31, 0x00	; 0
 648:	80 81       	ld	r24, Z
 64a:	88 60       	ori	r24, 0x08	; 8
 64c:	80 83       	st	Z, r24
 64e:	82 e0       	ldi	r24, 0x02	; 2
 650:	80 93 70 00 	sts	0x0070, r24	; 0x800070 <__TEXT_REGION_LENGTH__+0x7e0070>
 654:	08 95       	ret

00000656 <__vector_9>:
		}
}

ISR(TIMER2_COMP_vect){ //isr for timer2 
 656:	1f 92       	push	r1
 658:	0f 92       	push	r0
 65a:	0f b6       	in	r0, 0x3f	; 63
 65c:	0f 92       	push	r0
 65e:	11 24       	eor	r1, r1
 660:	0b b6       	in	r0, 0x3b	; 59
 662:	0f 92       	push	r0
 664:	8f 93       	push	r24
 666:	9f 93       	push	r25
 668:	af 93       	push	r26
 66a:	bf 93       	push	r27
 66c:	ef 93       	push	r30
 66e:	ff 93       	push	r31
	//cli(); // if cli() and sei() at the end are deployed, the code slows down immensly (longer sounds etc, but the overall r2d length does not get affected at all since its inside the ISR)
	PORTD ^= (1<<PD2);
 670:	9b b1       	in	r25, 0x0b	; 11
 672:	84 e0       	ldi	r24, 0x04	; 4
 674:	89 27       	eor	r24, r25
 676:	8b b9       	out	0x0b, r24	; 11
	OCR2A = song[note_next];
 678:	e0 91 1a 01 	lds	r30, 0x011A	; 0x80011a <note_next>
 67c:	f0 e0       	ldi	r31, 0x00	; 0
 67e:	ef 5f       	subi	r30, 0xFF	; 255
 680:	fe 4f       	sbci	r31, 0xFE	; 254
 682:	80 81       	ld	r24, Z
 684:	80 93 b3 00 	sts	0x00B3, r24	; 0x8000b3 <__TEXT_REGION_LENGTH__+0x7e00b3>
	r2d_length++;
 688:	80 91 1c 01 	lds	r24, 0x011C	; 0x80011c <r2d_length>
 68c:	90 91 1d 01 	lds	r25, 0x011D	; 0x80011d <r2d_length+0x1>
 690:	a0 91 1e 01 	lds	r26, 0x011E	; 0x80011e <r2d_length+0x2>
 694:	b0 91 1f 01 	lds	r27, 0x011F	; 0x80011f <r2d_length+0x3>
 698:	01 96       	adiw	r24, 0x01	; 1
 69a:	a1 1d       	adc	r26, r1
 69c:	b1 1d       	adc	r27, r1
 69e:	80 93 1c 01 	sts	0x011C, r24	; 0x80011c <r2d_length>
 6a2:	90 93 1d 01 	sts	0x011D, r25	; 0x80011d <r2d_length+0x1>
 6a6:	a0 93 1e 01 	sts	0x011E, r26	; 0x80011e <r2d_length+0x2>
 6aa:	b0 93 1f 01 	sts	0x011F, r27	; 0x80011f <r2d_length+0x3>
	//sei(); //magic?
 6ae:	ff 91       	pop	r31
 6b0:	ef 91       	pop	r30
 6b2:	bf 91       	pop	r27
 6b4:	af 91       	pop	r26
 6b6:	9f 91       	pop	r25
 6b8:	8f 91       	pop	r24
 6ba:	0f 90       	pop	r0
 6bc:	0b be       	out	0x3b, r0	; 59
 6be:	0f 90       	pop	r0
 6c0:	0f be       	out	0x3f, r0	; 63
 6c2:	0f 90       	pop	r0
 6c4:	1f 90       	pop	r1
 6c6:	18 95       	reti

000006c8 <_exit>:
 6c8:	f8 94       	cli

000006ca <__stop_program>:
 6ca:	ff cf       	rjmp	.-2      	; 0x6ca <__stop_program>
