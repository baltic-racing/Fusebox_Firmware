
Fusebox_Firmware.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000000a  00800100  000007fa  0000088e  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         000007fa  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000024  0080010a  0080010a  00000898  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00000898  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  000008c8  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000138  00000000  00000000  00000908  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00001539  00000000  00000000  00000a40  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000e7e  00000000  00000000  00001f79  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00000b77  00000000  00000000  00002df7  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  0000029c  00000000  00000000  00003970  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00000834  00000000  00000000  00003c0c  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00000491  00000000  00000000  00004440  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000000d8  00000000  00000000  000048d1  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	49 c0       	rjmp	.+146    	; 0x94 <__ctors_end>
   2:	00 00       	nop
   4:	64 c0       	rjmp	.+200    	; 0xce <__bad_interrupt>
   6:	00 00       	nop
   8:	62 c0       	rjmp	.+196    	; 0xce <__bad_interrupt>
   a:	00 00       	nop
   c:	60 c0       	rjmp	.+192    	; 0xce <__bad_interrupt>
   e:	00 00       	nop
  10:	5e c0       	rjmp	.+188    	; 0xce <__bad_interrupt>
  12:	00 00       	nop
  14:	5c c0       	rjmp	.+184    	; 0xce <__bad_interrupt>
  16:	00 00       	nop
  18:	5a c0       	rjmp	.+180    	; 0xce <__bad_interrupt>
  1a:	00 00       	nop
  1c:	58 c0       	rjmp	.+176    	; 0xce <__bad_interrupt>
  1e:	00 00       	nop
  20:	56 c0       	rjmp	.+172    	; 0xce <__bad_interrupt>
  22:	00 00       	nop
  24:	af c3       	rjmp	.+1886   	; 0x784 <__vector_9>
  26:	00 00       	nop
  28:	52 c0       	rjmp	.+164    	; 0xce <__bad_interrupt>
  2a:	00 00       	nop
  2c:	50 c0       	rjmp	.+160    	; 0xce <__bad_interrupt>
  2e:	00 00       	nop
  30:	b8 c1       	rjmp	.+880    	; 0x3a2 <__vector_12>
  32:	00 00       	nop
  34:	4c c0       	rjmp	.+152    	; 0xce <__bad_interrupt>
  36:	00 00       	nop
  38:	4a c0       	rjmp	.+148    	; 0xce <__bad_interrupt>
  3a:	00 00       	nop
  3c:	48 c0       	rjmp	.+144    	; 0xce <__bad_interrupt>
  3e:	00 00       	nop
  40:	6b c3       	rjmp	.+1750   	; 0x718 <__vector_16>
  42:	00 00       	nop
  44:	44 c0       	rjmp	.+136    	; 0xce <__bad_interrupt>
  46:	00 00       	nop
  48:	42 c0       	rjmp	.+132    	; 0xce <__bad_interrupt>
  4a:	00 00       	nop
  4c:	40 c0       	rjmp	.+128    	; 0xce <__bad_interrupt>
  4e:	00 00       	nop
  50:	3e c0       	rjmp	.+124    	; 0xce <__bad_interrupt>
  52:	00 00       	nop
  54:	3c c0       	rjmp	.+120    	; 0xce <__bad_interrupt>
  56:	00 00       	nop
  58:	3a c0       	rjmp	.+116    	; 0xce <__bad_interrupt>
  5a:	00 00       	nop
  5c:	38 c0       	rjmp	.+112    	; 0xce <__bad_interrupt>
  5e:	00 00       	nop
  60:	36 c0       	rjmp	.+108    	; 0xce <__bad_interrupt>
  62:	00 00       	nop
  64:	44 c0       	rjmp	.+136    	; 0xee <__vector_25>
  66:	00 00       	nop
  68:	32 c0       	rjmp	.+100    	; 0xce <__bad_interrupt>
  6a:	00 00       	nop
  6c:	30 c0       	rjmp	.+96     	; 0xce <__bad_interrupt>
  6e:	00 00       	nop
  70:	2e c0       	rjmp	.+92     	; 0xce <__bad_interrupt>
  72:	00 00       	nop
  74:	2c c0       	rjmp	.+88     	; 0xce <__bad_interrupt>
  76:	00 00       	nop
  78:	2a c0       	rjmp	.+84     	; 0xce <__bad_interrupt>
  7a:	00 00       	nop
  7c:	28 c0       	rjmp	.+80     	; 0xce <__bad_interrupt>
  7e:	00 00       	nop
  80:	26 c0       	rjmp	.+76     	; 0xce <__bad_interrupt>
  82:	00 00       	nop
  84:	24 c0       	rjmp	.+72     	; 0xce <__bad_interrupt>
  86:	00 00       	nop
  88:	22 c0       	rjmp	.+68     	; 0xce <__bad_interrupt>
  8a:	00 00       	nop
  8c:	20 c0       	rjmp	.+64     	; 0xce <__bad_interrupt>
  8e:	00 00       	nop
  90:	1e c0       	rjmp	.+60     	; 0xce <__bad_interrupt>
	...

00000094 <__ctors_end>:
  94:	11 24       	eor	r1, r1
  96:	1f be       	out	0x3f, r1	; 63
  98:	cf ef       	ldi	r28, 0xFF	; 255
  9a:	d0 e1       	ldi	r29, 0x10	; 16
  9c:	de bf       	out	0x3e, r29	; 62
  9e:	cd bf       	out	0x3d, r28	; 61

000000a0 <__do_copy_data>:
  a0:	11 e0       	ldi	r17, 0x01	; 1
  a2:	a0 e0       	ldi	r26, 0x00	; 0
  a4:	b1 e0       	ldi	r27, 0x01	; 1
  a6:	ea ef       	ldi	r30, 0xFA	; 250
  a8:	f7 e0       	ldi	r31, 0x07	; 7
  aa:	00 e0       	ldi	r16, 0x00	; 0
  ac:	0b bf       	out	0x3b, r16	; 59
  ae:	02 c0       	rjmp	.+4      	; 0xb4 <__do_copy_data+0x14>
  b0:	07 90       	elpm	r0, Z+
  b2:	0d 92       	st	X+, r0
  b4:	aa 30       	cpi	r26, 0x0A	; 10
  b6:	b1 07       	cpc	r27, r17
  b8:	d9 f7       	brne	.-10     	; 0xb0 <__do_copy_data+0x10>

000000ba <__do_clear_bss>:
  ba:	21 e0       	ldi	r18, 0x01	; 1
  bc:	aa e0       	ldi	r26, 0x0A	; 10
  be:	b1 e0       	ldi	r27, 0x01	; 1
  c0:	01 c0       	rjmp	.+2      	; 0xc4 <.do_clear_bss_start>

000000c2 <.do_clear_bss_loop>:
  c2:	1d 92       	st	X+, r1

000000c4 <.do_clear_bss_start>:
  c4:	ae 32       	cpi	r26, 0x2E	; 46
  c6:	b2 07       	cpc	r27, r18
  c8:	e1 f7       	brne	.-8      	; 0xc2 <.do_clear_bss_loop>
  ca:	80 d1       	rcall	.+768    	; 0x3cc <main>
  cc:	94 c3       	rjmp	.+1832   	; 0x7f6 <_exit>

000000ce <__bad_interrupt>:
  ce:	98 cf       	rjmp	.-208    	; 0x0 <__vectors>

000000d0 <adc_config>:
uint8_t adc_next = 0;



void adc_config(){
	ADMUX = (1<<REFS0); // AREF = AVcc and PF0 (ADC0) as input defined
  d0:	80 e4       	ldi	r24, 0x40	; 64
  d2:	80 93 7c 00 	sts	0x007C, r24	; 0x80007c <__TEXT_REGION_LENGTH__+0x7e007c>
	ADCSRA = (1<<ADEN) | (1<<ADPS2) | (0<<ADPS1) | (0<<ADPS0) | (1<<ADIE);
  d6:	ea e7       	ldi	r30, 0x7A	; 122
  d8:	f0 e0       	ldi	r31, 0x00	; 0
  da:	8c e8       	ldi	r24, 0x8C	; 140
  dc:	80 83       	st	Z, r24
	// ADEN enables ADC
	// ADIE enables ADC interrupt
	// ADPS (Prescaler) 16
	// see datasheet page 290
	ADCSRA |= (1<<ADSC); //start first conversion
  de:	80 81       	ld	r24, Z
  e0:	80 64       	ori	r24, 0x40	; 64
  e2:	80 83       	st	Z, r24
  e4:	08 95       	ret

000000e6 <adc_start_conversion>:
}

void adc_start_conversion(){
	//start next conversion with same config
	ADCSRA = (1<<ADEN) | (1<<ADIE) | (1<<ADSC);
  e6:	88 ec       	ldi	r24, 0xC8	; 200
  e8:	80 93 7a 00 	sts	0x007A, r24	; 0x80007a <__TEXT_REGION_LENGTH__+0x7e007a>
  ec:	08 95       	ret

000000ee <__vector_25>:
}

ISR(ADC_vect){
  ee:	1f 92       	push	r1
  f0:	0f 92       	push	r0
  f2:	0f b6       	in	r0, 0x3f	; 63
  f4:	0f 92       	push	r0
  f6:	11 24       	eor	r1, r1
  f8:	0b b6       	in	r0, 0x3b	; 59
  fa:	0f 92       	push	r0
  fc:	2f 93       	push	r18
  fe:	3f 93       	push	r19
 100:	4f 93       	push	r20
 102:	5f 93       	push	r21
 104:	6f 93       	push	r22
 106:	7f 93       	push	r23
 108:	8f 93       	push	r24
 10a:	9f 93       	push	r25
 10c:	af 93       	push	r26
 10e:	bf 93       	push	r27
 110:	ef 93       	push	r30
 112:	ff 93       	push	r31
	//cli();
	// store ADC result
	adc_values[adc_next] = ADC;// ADCL | (ADCH << 8); //low bit erst ablesen
 114:	80 91 0a 01 	lds	r24, 0x010A	; 0x80010a <__data_end>
 118:	e8 2f       	mov	r30, r24
 11a:	f0 e0       	ldi	r31, 0x00	; 0
 11c:	20 91 78 00 	lds	r18, 0x0078	; 0x800078 <__TEXT_REGION_LENGTH__+0x7e0078>
 120:	30 91 79 00 	lds	r19, 0x0079	; 0x800079 <__TEXT_REGION_LENGTH__+0x7e0079>
 124:	ee 0f       	add	r30, r30
 126:	ff 1f       	adc	r31, r31
 128:	e6 5d       	subi	r30, 0xD6	; 214
 12a:	fe 4f       	sbci	r31, 0xFE	; 254
 12c:	31 83       	std	Z+1, r19	; 0x01
 12e:	20 83       	st	Z, r18
	adc_next++;
 130:	8f 5f       	subi	r24, 0xFF	; 255
 132:	80 93 0a 01 	sts	0x010A, r24	; 0x80010a <__data_end>
	//adc_values[0] = (ADC*5)/1023;  //cant decide where in the code this should go without testing
	//adc_values[1] = ((ADC*5)/1023)+((10000*(ADC*5)/1023)/2500); //no way this is efficient, needs to be optimized later
	// reset index var
	//sei();
	if(adc_next == ADCVALUES){
 136:	82 30       	cpi	r24, 0x02	; 2
 138:	11 f4       	brne	.+4      	; 0x13e <__vector_25+0x50>
		adc_next = 0;
 13a:	10 92 0a 01 	sts	0x010A, r1	; 0x80010a <__data_end>
	}
	// select other ADC Input
	ADMUX = (1<<REFS0) | adc_next;
 13e:	80 91 0a 01 	lds	r24, 0x010A	; 0x80010a <__data_end>
 142:	80 64       	ori	r24, 0x40	; 64
 144:	80 93 7c 00 	sts	0x007C, r24	; 0x80007c <__TEXT_REGION_LENGTH__+0x7e007c>

	adc_start_conversion();
 148:	ce df       	rcall	.-100    	; 0xe6 <adc_start_conversion>
	//sei();
}
 14a:	ff 91       	pop	r31
 14c:	ef 91       	pop	r30
 14e:	bf 91       	pop	r27
 150:	af 91       	pop	r26
 152:	9f 91       	pop	r25
 154:	8f 91       	pop	r24
 156:	7f 91       	pop	r23
 158:	6f 91       	pop	r22
 15a:	5f 91       	pop	r21
 15c:	4f 91       	pop	r20
 15e:	3f 91       	pop	r19
 160:	2f 91       	pop	r18
 162:	0f 90       	pop	r0
 164:	0b be       	out	0x3b, r0	; 59
 166:	0f 90       	pop	r0
 168:	0f be       	out	0x3f, r0	; 63
 16a:	0f 90       	pop	r0
 16c:	1f 90       	pop	r1
 16e:	18 95       	reti

00000170 <adc_get>:

// getter for each adc var
uint16_t adc_get(uint8_t adc){
	
	return adc_values[adc];
 170:	e8 2f       	mov	r30, r24
 172:	f0 e0       	ldi	r31, 0x00	; 0
 174:	ee 0f       	add	r30, r30
 176:	ff 1f       	adc	r31, r31
 178:	e6 5d       	subi	r30, 0xD6	; 214
 17a:	fe 4f       	sbci	r31, 0xFE	; 254
}
 17c:	80 81       	ld	r24, Z
 17e:	91 81       	ldd	r25, Z+1	; 0x01
 180:	08 95       	ret

00000182 <can_check_free>:

uint8_t can_check_free(uint8_t mobnum){
	
	uint8_t mob_status = 0;
	
	if(mobnum >7){
 182:	88 30       	cpi	r24, 0x08	; 8
 184:	78 f0       	brcs	.+30     	; 0x1a4 <can_check_free+0x22>
		
		mob_status = !((CANEN1 >> (mobnum-8)) &1);
 186:	20 91 dd 00 	lds	r18, 0x00DD	; 0x8000dd <__TEXT_REGION_LENGTH__+0x7e00dd>
 18a:	90 e0       	ldi	r25, 0x00	; 0
 18c:	08 97       	sbiw	r24, 0x08	; 8
 18e:	30 e0       	ldi	r19, 0x00	; 0
 190:	02 c0       	rjmp	.+4      	; 0x196 <can_check_free+0x14>
 192:	35 95       	asr	r19
 194:	27 95       	ror	r18
 196:	8a 95       	dec	r24
 198:	e2 f7       	brpl	.-8      	; 0x192 <can_check_free+0x10>
 19a:	81 e0       	ldi	r24, 0x01	; 1
 19c:	20 ff       	sbrs	r18, 0
 19e:	0d c0       	rjmp	.+26     	; 0x1ba <can_check_free+0x38>
 1a0:	80 e0       	ldi	r24, 0x00	; 0
 1a2:	08 95       	ret


		} else {
		
		mob_status = !((CANEN2 >> mobnum) &1);
 1a4:	20 91 dc 00 	lds	r18, 0x00DC	; 0x8000dc <__TEXT_REGION_LENGTH__+0x7e00dc>
 1a8:	30 e0       	ldi	r19, 0x00	; 0
 1aa:	02 c0       	rjmp	.+4      	; 0x1b0 <can_check_free+0x2e>
 1ac:	35 95       	asr	r19
 1ae:	27 95       	ror	r18
 1b0:	8a 95       	dec	r24
 1b2:	e2 f7       	brpl	.-8      	; 0x1ac <can_check_free+0x2a>
 1b4:	81 e0       	ldi	r24, 0x01	; 1
 1b6:	20 fd       	sbrc	r18, 0
 1b8:	80 e0       	ldi	r24, 0x00	; 0
	}

	return mob_status;
	
}
 1ba:	08 95       	ret

000001bc <can_cfg>:
void can_cfg(){
	
	CANGCON = 0; // Disable CAN
 1bc:	10 92 d8 00 	sts	0x00D8, r1	; 0x8000d8 <__TEXT_REGION_LENGTH__+0x7e00d8>
	
	for (uint8_t mob = 0; mob < 15 ; mob++){//reset all mobs
 1c0:	40 e0       	ldi	r20, 0x00	; 0
 1c2:	29 c0       	rjmp	.+82     	; 0x216 <can_cfg+0x5a>
		CANPAGE = mob<<MOBNB0 | (1<<AINC);
 1c4:	80 e1       	ldi	r24, 0x10	; 16
 1c6:	48 9f       	mul	r20, r24
 1c8:	90 01       	movw	r18, r0
 1ca:	11 24       	eor	r1, r1
 1cc:	82 2f       	mov	r24, r18
 1ce:	88 60       	ori	r24, 0x08	; 8
 1d0:	80 93 ed 00 	sts	0x00ED, r24	; 0x8000ed <__TEXT_REGION_LENGTH__+0x7e00ed>
		CANSTMOB = 0;
 1d4:	10 92 ee 00 	sts	0x00EE, r1	; 0x8000ee <__TEXT_REGION_LENGTH__+0x7e00ee>
		CANCDMOB = 0;
 1d8:	10 92 ef 00 	sts	0x00EF, r1	; 0x8000ef <__TEXT_REGION_LENGTH__+0x7e00ef>
		CANIDT4 = 0;
 1dc:	10 92 f0 00 	sts	0x00F0, r1	; 0x8000f0 <__TEXT_REGION_LENGTH__+0x7e00f0>
		CANIDT3 = 0;
 1e0:	10 92 f1 00 	sts	0x00F1, r1	; 0x8000f1 <__TEXT_REGION_LENGTH__+0x7e00f1>
		CANIDT2 = 0;
 1e4:	10 92 f2 00 	sts	0x00F2, r1	; 0x8000f2 <__TEXT_REGION_LENGTH__+0x7e00f2>
		CANIDT1 = 0;
 1e8:	10 92 f3 00 	sts	0x00F3, r1	; 0x8000f3 <__TEXT_REGION_LENGTH__+0x7e00f3>
		CANIDM4 = 0;
 1ec:	10 92 f4 00 	sts	0x00F4, r1	; 0x8000f4 <__TEXT_REGION_LENGTH__+0x7e00f4>
		CANIDM3 = 0;
 1f0:	10 92 f5 00 	sts	0x00F5, r1	; 0x8000f5 <__TEXT_REGION_LENGTH__+0x7e00f5>
		CANIDM2 = 0;
 1f4:	10 92 f6 00 	sts	0x00F6, r1	; 0x8000f6 <__TEXT_REGION_LENGTH__+0x7e00f6>
		CANIDM1 = 0;
 1f8:	10 92 f7 00 	sts	0x00F7, r1	; 0x8000f7 <__TEXT_REGION_LENGTH__+0x7e00f7>
		for (uint8_t byte = 0; byte < 8; byte++){
 1fc:	80 e0       	ldi	r24, 0x00	; 0
 1fe:	08 c0       	rjmp	.+16     	; 0x210 <can_cfg+0x54>
			CANPAGE = mob<<MOBNB0 | 1<<AINC | byte;
 200:	98 2f       	mov	r25, r24
 202:	92 2b       	or	r25, r18
 204:	98 60       	ori	r25, 0x08	; 8
 206:	90 93 ed 00 	sts	0x00ED, r25	; 0x8000ed <__TEXT_REGION_LENGTH__+0x7e00ed>
			CANMSG = 0;
 20a:	10 92 fa 00 	sts	0x00FA, r1	; 0x8000fa <__TEXT_REGION_LENGTH__+0x7e00fa>
		CANIDT1 = 0;
		CANIDM4 = 0;
		CANIDM3 = 0;
		CANIDM2 = 0;
		CANIDM1 = 0;
		for (uint8_t byte = 0; byte < 8; byte++){
 20e:	8f 5f       	subi	r24, 0xFF	; 255
 210:	88 30       	cpi	r24, 0x08	; 8
 212:	b0 f3       	brcs	.-20     	; 0x200 <can_cfg+0x44>
}
void can_cfg(){
	
	CANGCON = 0; // Disable CAN
	
	for (uint8_t mob = 0; mob < 15 ; mob++){//reset all mobs
 214:	4f 5f       	subi	r20, 0xFF	; 255
 216:	4f 30       	cpi	r20, 0x0F	; 15
 218:	a8 f2       	brcs	.-86     	; 0x1c4 <can_cfg+0x8>
			CANPAGE = mob<<MOBNB0 | 1<<AINC | byte;
			CANMSG = 0;
		}
	}

	CANBT1 = 0x00;// Set Baudrate
 21a:	10 92 e2 00 	sts	0x00E2, r1	; 0x8000e2 <__TEXT_REGION_LENGTH__+0x7e00e2>
	CANBT2 = 0x0C;// 500kBaud according
 21e:	8c e0       	ldi	r24, 0x0C	; 12
 220:	80 93 e3 00 	sts	0x00E3, r24	; 0x8000e3 <__TEXT_REGION_LENGTH__+0x7e00e3>
	CANBT3 = 0x36;// to Datasheet S. 267
 224:	86 e3       	ldi	r24, 0x36	; 54
 226:	80 93 e4 00 	sts	0x00E4, r24	; 0x8000e4 <__TEXT_REGION_LENGTH__+0x7e00e4>

	CANGIE = 0;
 22a:	10 92 db 00 	sts	0x00DB, r1	; 0x8000db <__TEXT_REGION_LENGTH__+0x7e00db>

	CANGCON |= (1<<ENASTB); // Enable CAN
 22e:	e8 ed       	ldi	r30, 0xD8	; 216
 230:	f0 e0       	ldi	r31, 0x00	; 0
 232:	80 81       	ld	r24, Z
 234:	82 60       	ori	r24, 0x02	; 2
 236:	80 83       	st	Z, r24
 238:	08 95       	ret

0000023a <can_rx>:
	
	
	
}
void can_rx(struct CAN_MOB *to_receive, uint8_t *data){
 23a:	0f 93       	push	r16
 23c:	1f 93       	push	r17
 23e:	cf 93       	push	r28
 240:	df 93       	push	r29
 242:	ec 01       	movw	r28, r24
 244:	8b 01       	movw	r16, r22
	
	CANPAGE = to_receive->mob_number << MOBNB0;
 246:	8c 81       	ldd	r24, Y+4	; 0x04
 248:	82 95       	swap	r24
 24a:	80 7f       	andi	r24, 0xF0	; 240
 24c:	80 93 ed 00 	sts	0x00ED, r24	; 0x8000ed <__TEXT_REGION_LENGTH__+0x7e00ed>
	if (can_check_free(to_receive->mob_number)){
 250:	8c 81       	ldd	r24, Y+4	; 0x04
 252:	97 df       	rcall	.-210    	; 0x182 <can_check_free>
 254:	88 23       	and	r24, r24
 256:	71 f1       	breq	.+92     	; 0x2b4 <can_rx+0x7a>
		/* load the id 11 bit */
		CANIDT1 = to_receive->mob_id >>3;
 258:	88 81       	ld	r24, Y
 25a:	99 81       	ldd	r25, Y+1	; 0x01
 25c:	96 95       	lsr	r25
 25e:	87 95       	ror	r24
 260:	96 95       	lsr	r25
 262:	87 95       	ror	r24
 264:	96 95       	lsr	r25
 266:	87 95       	ror	r24
 268:	80 93 f3 00 	sts	0x00F3, r24	; 0x8000f3 <__TEXT_REGION_LENGTH__+0x7e00f3>
		CANIDT2 = (to_receive->mob_id << 5)&0b11100000;
 26c:	88 81       	ld	r24, Y
 26e:	82 95       	swap	r24
 270:	88 0f       	add	r24, r24
 272:	80 7e       	andi	r24, 0xE0	; 224
 274:	80 93 f2 00 	sts	0x00F2, r24	; 0x8000f2 <__TEXT_REGION_LENGTH__+0x7e00f2>
		CANIDT3 = 0;
 278:	10 92 f1 00 	sts	0x00F1, r1	; 0x8000f1 <__TEXT_REGION_LENGTH__+0x7e00f1>
		CANIDT4 = 1<<RTRTAG;
 27c:	84 e0       	ldi	r24, 0x04	; 4
 27e:	80 93 f0 00 	sts	0x00F0, r24	; 0x8000f0 <__TEXT_REGION_LENGTH__+0x7e00f0>
		CANIDM1 = to_receive->mob_idmask >>3;
 282:	8a 81       	ldd	r24, Y+2	; 0x02
 284:	9b 81       	ldd	r25, Y+3	; 0x03
 286:	96 95       	lsr	r25
 288:	87 95       	ror	r24
 28a:	96 95       	lsr	r25
 28c:	87 95       	ror	r24
 28e:	96 95       	lsr	r25
 290:	87 95       	ror	r24
 292:	80 93 f7 00 	sts	0x00F7, r24	; 0x8000f7 <__TEXT_REGION_LENGTH__+0x7e00f7>
		CANIDM2 = (to_receive->mob_idmask <<5)&0b11100000;
 296:	8a 81       	ldd	r24, Y+2	; 0x02
 298:	82 95       	swap	r24
 29a:	88 0f       	add	r24, r24
 29c:	80 7e       	andi	r24, 0xE0	; 224
 29e:	80 93 f6 00 	sts	0x00F6, r24	; 0x8000f6 <__TEXT_REGION_LENGTH__+0x7e00f6>
		CANIDM3 = 0;
 2a2:	10 92 f5 00 	sts	0x00F5, r1	; 0x8000f5 <__TEXT_REGION_LENGTH__+0x7e00f5>
		CANIDM4 = 0;
 2a6:	10 92 f4 00 	sts	0x00F4, r1	; 0x8000f4 <__TEXT_REGION_LENGTH__+0x7e00f4>
		CANCDMOB = (1 << CONMOB1) | (1 << CONMOB0)| (1<<DLC3);
 2aa:	88 ec       	ldi	r24, 0xC8	; 200
 2ac:	80 93 ef 00 	sts	0x00EF, r24	; 0x8000ef <__TEXT_REGION_LENGTH__+0x7e00ef>
		CANSTMOB = 0;
 2b0:	10 92 ee 00 	sts	0x00EE, r1	; 0x8000ee <__TEXT_REGION_LENGTH__+0x7e00ee>
	CANGCON |= (1<<ENASTB); // Enable CAN
	
	
	
}
void can_rx(struct CAN_MOB *to_receive, uint8_t *data){
 2b4:	20 e0       	ldi	r18, 0x00	; 0
 2b6:	10 c0       	rjmp	.+32     	; 0x2d8 <can_rx+0x9e>
		CANCDMOB = (1 << CONMOB1) | (1 << CONMOB0)| (1<<DLC3);
		CANSTMOB = 0;
	}
	
	for(uint8_t byte = 0; byte <8; byte++){
		CANPAGE = (to_receive->mob_number << MOBNB0) | (1 << AINC) | byte;
 2b8:	8c 81       	ldd	r24, Y+4	; 0x04
 2ba:	30 e1       	ldi	r19, 0x10	; 16
 2bc:	83 9f       	mul	r24, r19
 2be:	c0 01       	movw	r24, r0
 2c0:	11 24       	eor	r1, r1
 2c2:	82 2b       	or	r24, r18
 2c4:	88 60       	ori	r24, 0x08	; 8
 2c6:	80 93 ed 00 	sts	0x00ED, r24	; 0x8000ed <__TEXT_REGION_LENGTH__+0x7e00ed>
		data[byte] = CANMSG;
 2ca:	f8 01       	movw	r30, r16
 2cc:	e2 0f       	add	r30, r18
 2ce:	f1 1d       	adc	r31, r1
 2d0:	80 91 fa 00 	lds	r24, 0x00FA	; 0x8000fa <__TEXT_REGION_LENGTH__+0x7e00fa>
 2d4:	80 83       	st	Z, r24
		CANIDM4 = 0;
		CANCDMOB = (1 << CONMOB1) | (1 << CONMOB0)| (1<<DLC3);
		CANSTMOB = 0;
	}
	
	for(uint8_t byte = 0; byte <8; byte++){
 2d6:	2f 5f       	subi	r18, 0xFF	; 255
 2d8:	28 30       	cpi	r18, 0x08	; 8
 2da:	70 f3       	brcs	.-36     	; 0x2b8 <can_rx+0x7e>
		CANPAGE = (to_receive->mob_number << MOBNB0) | (1 << AINC) | byte;
		data[byte] = CANMSG;
	}
	
	
}
 2dc:	df 91       	pop	r29
 2de:	cf 91       	pop	r28
 2e0:	1f 91       	pop	r17
 2e2:	0f 91       	pop	r16
 2e4:	08 95       	ret

000002e6 <can_tx>:
void can_tx(struct CAN_MOB *to_send, uint8_t *data){
 2e6:	cf 93       	push	r28
 2e8:	df 93       	push	r29
 2ea:	ec 01       	movw	r28, r24
	
	for(uint8_t byte = 0; byte <8; byte++){
 2ec:	20 e0       	ldi	r18, 0x00	; 0
 2ee:	10 c0       	rjmp	.+32     	; 0x310 <can_tx+0x2a>
		CANPAGE = (to_send->mob_number << MOBNB0) | (1 << AINC) | byte;
 2f0:	8c 81       	ldd	r24, Y+4	; 0x04
 2f2:	30 e1       	ldi	r19, 0x10	; 16
 2f4:	83 9f       	mul	r24, r19
 2f6:	c0 01       	movw	r24, r0
 2f8:	11 24       	eor	r1, r1
 2fa:	82 2b       	or	r24, r18
 2fc:	88 60       	ori	r24, 0x08	; 8
 2fe:	80 93 ed 00 	sts	0x00ED, r24	; 0x8000ed <__TEXT_REGION_LENGTH__+0x7e00ed>
		CANMSG = data[byte];
 302:	fb 01       	movw	r30, r22
 304:	e2 0f       	add	r30, r18
 306:	f1 1d       	adc	r31, r1
 308:	80 81       	ld	r24, Z
 30a:	80 93 fa 00 	sts	0x00FA, r24	; 0x8000fa <__TEXT_REGION_LENGTH__+0x7e00fa>
	
	
}
void can_tx(struct CAN_MOB *to_send, uint8_t *data){
	
	for(uint8_t byte = 0; byte <8; byte++){
 30e:	2f 5f       	subi	r18, 0xFF	; 255
 310:	28 30       	cpi	r18, 0x08	; 8
 312:	70 f3       	brcs	.-36     	; 0x2f0 <can_tx+0xa>
		CANPAGE = (to_send->mob_number << MOBNB0) | (1 << AINC) | byte;
		CANMSG = data[byte];
	}
	
	CANPAGE = to_send->mob_number << MOBNB0;
 314:	8c 81       	ldd	r24, Y+4	; 0x04
 316:	82 95       	swap	r24
 318:	80 7f       	andi	r24, 0xF0	; 240
 31a:	80 93 ed 00 	sts	0x00ED, r24	; 0x8000ed <__TEXT_REGION_LENGTH__+0x7e00ed>
	if (can_check_free(to_send->mob_number)){
 31e:	8c 81       	ldd	r24, Y+4	; 0x04
 320:	30 df       	rcall	.-416    	; 0x182 <can_check_free>
 322:	88 23       	and	r24, r24
 324:	21 f1       	breq	.+72     	; 0x36e <can_tx+0x88>
		CANSTMOB = 0;
 326:	ee ee       	ldi	r30, 0xEE	; 238
 328:	f0 e0       	ldi	r31, 0x00	; 0
 32a:	10 82       	st	Z, r1
		CANIDT1 = to_send->mob_id>>3;
 32c:	88 81       	ld	r24, Y
 32e:	99 81       	ldd	r25, Y+1	; 0x01
 330:	96 95       	lsr	r25
 332:	87 95       	ror	r24
 334:	96 95       	lsr	r25
 336:	87 95       	ror	r24
 338:	96 95       	lsr	r25
 33a:	87 95       	ror	r24
 33c:	80 93 f3 00 	sts	0x00F3, r24	; 0x8000f3 <__TEXT_REGION_LENGTH__+0x7e00f3>
		CANIDT2 = (to_send->mob_id << 5) & 0b11100000;
 340:	88 81       	ld	r24, Y
 342:	82 95       	swap	r24
 344:	88 0f       	add	r24, r24
 346:	80 7e       	andi	r24, 0xE0	; 224
 348:	80 93 f2 00 	sts	0x00F2, r24	; 0x8000f2 <__TEXT_REGION_LENGTH__+0x7e00f2>
		CANIDT3 = 0;
 34c:	10 92 f1 00 	sts	0x00F1, r1	; 0x8000f1 <__TEXT_REGION_LENGTH__+0x7e00f1>
		CANIDT4 = 0;
 350:	10 92 f0 00 	sts	0x00F0, r1	; 0x8000f0 <__TEXT_REGION_LENGTH__+0x7e00f0>
		CANIDM1 = 0; //0b11111111;
 354:	10 92 f7 00 	sts	0x00F7, r1	; 0x8000f7 <__TEXT_REGION_LENGTH__+0x7e00f7>
		CANIDM2 = 0; //0b11100000;
 358:	10 92 f6 00 	sts	0x00F6, r1	; 0x8000f6 <__TEXT_REGION_LENGTH__+0x7e00f6>
		CANIDM3 = 0;
 35c:	10 92 f5 00 	sts	0x00F5, r1	; 0x8000f5 <__TEXT_REGION_LENGTH__+0x7e00f5>
		CANIDM4 = 0;
 360:	10 92 f4 00 	sts	0x00F4, r1	; 0x8000f4 <__TEXT_REGION_LENGTH__+0x7e00f4>
		CANSTMOB = 0;
 364:	10 82       	st	Z, r1
		CANCDMOB = (1<<CONMOB0) | 1 << DLC3;
 366:	88 e4       	ldi	r24, 0x48	; 72
 368:	80 93 ef 00 	sts	0x00EF, r24	; 0x8000ef <__TEXT_REGION_LENGTH__+0x7e00ef>
		CANSTMOB = 0;
 36c:	10 82       	st	Z, r1
	}
	
}
 36e:	df 91       	pop	r29
 370:	cf 91       	pop	r28
 372:	08 95       	ret

00000374 <timer1_config>:
		fan_duty = (temperature*63)/100;
	}	
}

void timer1_config(){	
DDRB |= (1<<PB6);			// setting COM1nx Bits not necessary because we can also toggle/set pins using the ISR, here the Fan PWM cable is already on the Pin toggled by those bits											
 374:	84 b1       	in	r24, 0x04	; 4
 376:	80 64       	ori	r24, 0x40	; 64
 378:	84 b9       	out	0x04, r24	; 4
TCCR1A = (1<<WGM11) | (1<<WGM10) | (0<<COM1A1) | (1<<COM1A0) | (1<<COM1B1);	//mode 15, prescaler 8, non inverted mode => page 138 - 139  
 37a:	83 e6       	ldi	r24, 0x63	; 99
 37c:	80 93 80 00 	sts	0x0080, r24	; 0x800080 <__TEXT_REGION_LENGTH__+0x7e0080>
TCCR1B = (1<<WGM13) | (1<<WGM12) | (1<<CS11);								// Fast PWM description => page 128
 380:	8a e1       	ldi	r24, 0x1A	; 26
 382:	80 93 81 00 	sts	0x0081, r24	; 0x800081 <__TEXT_REGION_LENGTH__+0x7e0081>
TIMSK1 = (1<<OCIE1A);														//Output Compare interrupt flag will be set whenever OCR1A is reached
 386:	82 e0       	ldi	r24, 0x02	; 2
 388:	80 93 6f 00 	sts	0x006F, r24	; 0x80006f <__TEXT_REGION_LENGTH__+0x7e006f>
OCR1A = 63;													// TOP  16000000/(8*(1+64)) = 30769.23077 Hz = ~30kHz => page 130   with TOP value 62+1 the resolution is 6 bit => page 128
 38c:	8f e3       	ldi	r24, 0x3F	; 63
 38e:	90 e0       	ldi	r25, 0x00	; 0
 390:	90 93 89 00 	sts	0x0089, r25	; 0x800089 <__TEXT_REGION_LENGTH__+0x7e0089>
 394:	80 93 88 00 	sts	0x0088, r24	; 0x800088 <__TEXT_REGION_LENGTH__+0x7e0088>
OCR1B = 0;													// BOTTOM
 398:	10 92 8b 00 	sts	0x008B, r1	; 0x80008b <__TEXT_REGION_LENGTH__+0x7e008b>
 39c:	10 92 8a 00 	sts	0x008A, r1	; 0x80008a <__TEXT_REGION_LENGTH__+0x7e008a>
 3a0:	08 95       	ret

000003a2 <__vector_12>:
}

ISR(TIMER1_COMPA_vect){									//ISR for the timer 1, updating the duty cycle
 3a2:	1f 92       	push	r1
 3a4:	0f 92       	push	r0
 3a6:	0f b6       	in	r0, 0x3f	; 63
 3a8:	0f 92       	push	r0
 3aa:	11 24       	eor	r1, r1
 3ac:	8f 93       	push	r24
 3ae:	9f 93       	push	r25
//cli();
OCR1B = fan_duty;
 3b0:	80 91 0b 01 	lds	r24, 0x010B	; 0x80010b <fan_duty>
 3b4:	90 e0       	ldi	r25, 0x00	; 0
 3b6:	90 93 8b 00 	sts	0x008B, r25	; 0x80008b <__TEXT_REGION_LENGTH__+0x7e008b>
 3ba:	80 93 8a 00 	sts	0x008A, r24	; 0x80008a <__TEXT_REGION_LENGTH__+0x7e008a>
//sei();
 3be:	9f 91       	pop	r25
 3c0:	8f 91       	pop	r24
 3c2:	0f 90       	pop	r0
 3c4:	0f be       	out	0x3f, r0	; 63
 3c6:	0f 90       	pop	r0
 3c8:	1f 90       	pop	r1
 3ca:	18 95       	reti

000003cc <main>:
volatile uint8_t x = 0;

extern volatile uint8_t fan_duty;
uint8_t R2D_pressed = 0;

int main(void){
 3cc:	cf 93       	push	r28
 3ce:	df 93       	push	r29
 3d0:	cd b7       	in	r28, 0x3d	; 61
 3d2:	de b7       	in	r29, 0x3e	; 62
 3d4:	c1 54       	subi	r28, 0x41	; 65
 3d6:	d1 09       	sbc	r29, r1
 3d8:	0f b6       	in	r0, 0x3f	; 63
 3da:	f8 94       	cli
 3dc:	de bf       	out	0x3e, r29	; 62
 3de:	0f be       	out	0x3f, r0	; 63
 3e0:	cd bf       	out	0x3d, r28	; 61

sys_timer_config();
 3e2:	87 d1       	rcall	.+782    	; 0x6f2 <sys_timer_config>
port_config();
 3e4:	7d d1       	rcall	.+762    	; 0x6e0 <port_config>
can_cfg();
 3e6:	ea de       	rcall	.-556    	; 0x1bc <can_cfg>
adc_config();
 3e8:	73 de       	rcall	.-794    	; 0xd0 <adc_config>
 3ea:	c3 d1       	rcall	.+902    	; 0x772 <timer2_config>
timer2_config();
 3ec:	c3 df       	rcall	.-122    	; 0x374 <timer1_config>
 3ee:	1c 82       	std	Y+4, r1	; 0x04
timer1_config();
 3f0:	1b 82       	std	Y+3, r1	; 0x03
 3f2:	81 e0       	ldi	r24, 0x01	; 1



struct CAN_MOB can_Fusebox0_mob;
can_Fusebox0_mob.mob_id = 0x600;
can_Fusebox0_mob.mob_idmask = 0; //sent
 3f4:	96 e0       	ldi	r25, 0x06	; 6
 3f6:	9a 83       	std	Y+2, r25	; 0x02
can_Fusebox0_mob.mob_number = 1;
uint8_t Fusebox0_databytes[8];

struct CAN_MOB can_Fusebox1_mob;
can_Fusebox0_mob.mob_id = 0x601;
 3f8:	89 83       	std	Y+1, r24	; 0x01
 3fa:	82 e0       	ldi	r24, 0x02	; 2
 3fc:	8d 83       	std	Y+5, r24	; 0x05
 3fe:	80 e0       	ldi	r24, 0x00	; 0
can_Fusebox0_mob.mob_idmask = 0; //sent
can_Fusebox0_mob.mob_number = 2;
 400:	94 e0       	ldi	r25, 0x04	; 4
 402:	9c 8f       	std	Y+28, r25	; 0x1c
uint8_t Fusebox1_databytes[8];


struct CAN_MOB can_SHR0_mob;
can_SHR0_mob.mob_id = 0x400;
 404:	8b 8f       	std	Y+27, r24	; 0x1b
 406:	8f ef       	ldi	r24, 0xFF	; 255
 408:	97 e0       	ldi	r25, 0x07	; 7
 40a:	9e 8f       	std	Y+30, r25	; 0x1e
can_SHR0_mob.mob_idmask = 0b11111111111; //receive with no filer?
 40c:	8d 8f       	std	Y+29, r24	; 0x1d
 40e:	23 e0       	ldi	r18, 0x03	; 3
 410:	2f 8f       	std	Y+31, r18	; 0x1f
 412:	20 e2       	ldi	r18, 0x20	; 32
can_SHR0_mob.mob_number = 3;  //IDs might be wrong
 414:	34 e0       	ldi	r19, 0x04	; 4
 416:	39 a7       	std	Y+41, r19	; 0x29
uint8_t SHR0_databytes[8];

struct CAN_MOB can_SHB0_mob;
can_SHB0_mob.mob_id = 0x420;
 418:	28 a7       	std	Y+40, r18	; 0x28
 41a:	9b a7       	std	Y+43, r25	; 0x2b
 41c:	8a a7       	std	Y+42, r24	; 0x2a
 41e:	85 e0       	ldi	r24, 0x05	; 5
can_SHB0_mob.mob_idmask = 0b11111111111; //receive with no filter?
 420:	8c a7       	std	Y+44, r24	; 0x2c
 422:	80 e0       	ldi	r24, 0x00	; 0
can_SHB0_mob.mob_number = 5;
 424:	95 e0       	ldi	r25, 0x05	; 5
 426:	9e ab       	std	Y+54, r25	; 0x36
uint8_t SHB0_databytes[8];

struct CAN_MOB can_DIC0_mob;	
can_DIC0_mob.mob_id = 0x500;
 428:	8d ab       	std	Y+53, r24	; 0x35
 42a:	8f ef       	ldi	r24, 0xFF	; 255
 42c:	9f ef       	ldi	r25, 0xFF	; 255
 42e:	98 af       	std	Y+56, r25	; 0x38
can_DIC0_mob.mob_idmask = 0xffff;
 430:	8f ab       	std	Y+55, r24	; 0x37
 432:	8b e0       	ldi	r24, 0x0B	; 11
 434:	89 af       	std	Y+57, r24	; 0x39
 436:	78 94       	sei
can_DIC0_mob.mob_number = 11;
 438:	24 c0       	rjmp	.+72     	; 0x482 <__LOCK_REGION_LENGTH__+0x82>
 43a:	40 91 0c 01 	lds	r20, 0x010C	; 0x80010c <useless_variable>
uint8_t DIC0_databytes[8];


sei();
	
	while (sys_time < 5000){ //3s to let fan arm
 43e:	50 91 0d 01 	lds	r21, 0x010D	; 0x80010d <useless_variable+0x1>
			if ((sys_time-useless_variable) > 200 ){			//every 200ms increment duty up to 15/63				//nesting only for testing purposes
 442:	60 91 0e 01 	lds	r22, 0x010E	; 0x80010e <useless_variable+0x2>
 446:	70 91 0f 01 	lds	r23, 0x010F	; 0x80010f <useless_variable+0x3>
 44a:	8c 01       	movw	r16, r24
 44c:	9d 01       	movw	r18, r26
 44e:	04 1b       	sub	r16, r20
 450:	15 0b       	sbc	r17, r21
 452:	26 0b       	sbc	r18, r22
 454:	37 0b       	sbc	r19, r23
 456:	09 3c       	cpi	r16, 0xC9	; 201
 458:	11 05       	cpc	r17, r1
 45a:	21 05       	cpc	r18, r1
 45c:	31 05       	cpc	r19, r1
 45e:	88 f0       	brcs	.+34     	; 0x482 <__LOCK_REGION_LENGTH__+0x82>
 460:	80 93 0c 01 	sts	0x010C, r24	; 0x80010c <useless_variable>
 464:	90 93 0d 01 	sts	0x010D, r25	; 0x80010d <useless_variable+0x1>
				useless_variable = sys_time;					//edit: 100ms intervals up to 15 and back to 0
 468:	a0 93 0e 01 	sts	0x010E, r26	; 0x80010e <useless_variable+0x2>
 46c:	b0 93 0f 01 	sts	0x010F, r27	; 0x80010f <useless_variable+0x3>
 470:	80 91 0b 01 	lds	r24, 0x010B	; 0x80010b <fan_duty>
 474:	89 32       	cpi	r24, 0x29	; 41
				if (fan_duty <= 40){
 476:	28 f4       	brcc	.+10     	; 0x482 <__LOCK_REGION_LENGTH__+0x82>
 478:	80 91 0b 01 	lds	r24, 0x010B	; 0x80010b <fan_duty>
 47c:	8f 5f       	subi	r24, 0xFF	; 255
					fan_duty++;  //
 47e:	80 93 0b 01 	sts	0x010B, r24	; 0x80010b <fan_duty>
 482:	80 91 20 01 	lds	r24, 0x0120	; 0x800120 <sys_time>
 486:	90 91 21 01 	lds	r25, 0x0121	; 0x800121 <sys_time+0x1>
uint8_t DIC0_databytes[8];


sei();
	
	while (sys_time < 5000){ //3s to let fan arm
 48a:	a0 91 22 01 	lds	r26, 0x0122	; 0x800122 <sys_time+0x2>
 48e:	b0 91 23 01 	lds	r27, 0x0123	; 0x800123 <sys_time+0x3>
 492:	88 38       	cpi	r24, 0x88	; 136
 494:	13 e1       	ldi	r17, 0x13	; 19
 496:	91 07       	cpc	r25, r17
 498:	a1 05       	cpc	r26, r1
 49a:	b1 05       	cpc	r27, r1
 49c:	70 f2       	brcs	.-100    	; 0x43a <__LOCK_REGION_LENGTH__+0x3a>
 49e:	80 91 20 01 	lds	r24, 0x0120	; 0x800120 <sys_time>
 4a2:	90 91 21 01 	lds	r25, 0x0121	; 0x800121 <sys_time+0x1>
// 				}
			}
		//}
	}
	while (1){
		if(TIME_PASSED_10_MS){			// (sys_time - time_old) > 10
 4a6:	a0 91 22 01 	lds	r26, 0x0122	; 0x800122 <sys_time+0x2>
 4aa:	b0 91 23 01 	lds	r27, 0x0123	; 0x800123 <sys_time+0x3>
 4ae:	40 91 1c 01 	lds	r20, 0x011C	; 0x80011c <time_old>
 4b2:	50 91 1d 01 	lds	r21, 0x011D	; 0x80011d <time_old+0x1>
 4b6:	60 91 1e 01 	lds	r22, 0x011E	; 0x80011e <time_old+0x2>
 4ba:	70 91 1f 01 	lds	r23, 0x011F	; 0x80011f <time_old+0x3>
 4be:	8c 01       	movw	r16, r24
 4c0:	9d 01       	movw	r18, r26
 4c2:	04 1b       	sub	r16, r20
 4c4:	15 0b       	sbc	r17, r21
 4c6:	26 0b       	sbc	r18, r22
 4c8:	37 0b       	sbc	r19, r23
 4ca:	0b 30       	cpi	r16, 0x0B	; 11
 4cc:	11 05       	cpc	r17, r1
 4ce:	21 05       	cpc	r18, r1
 4d0:	31 05       	cpc	r19, r1
 4d2:	08 f4       	brcc	.+2      	; 0x4d6 <__LOCK_REGION_LENGTH__+0xd6>
 4d4:	c2 c0       	rjmp	.+388    	; 0x65a <__LOCK_REGION_LENGTH__+0x25a>
 4d6:	80 93 1c 01 	sts	0x011C, r24	; 0x80011c <time_old>
 4da:	90 93 1d 01 	sts	0x011D, r25	; 0x80011d <time_old+0x1>
			time_old = sys_time; 
 4de:	a0 93 1e 01 	sts	0x011E, r26	; 0x80011e <time_old+0x2>
 4e2:	b0 93 1f 01 	sts	0x011F, r27	; 0x80011f <time_old+0x3>
 4e6:	80 91 18 01 	lds	r24, 0x0118	; 0x800118 <time_old_100ms>
 4ea:	90 91 19 01 	lds	r25, 0x0119	; 0x800119 <time_old_100ms+0x1>
			time_old_100ms++;   //FIND BETTER NAME, WHY OLD??
 4ee:	a0 91 1a 01 	lds	r26, 0x011A	; 0x80011a <time_old_100ms+0x2>
 4f2:	b0 91 1b 01 	lds	r27, 0x011B	; 0x80011b <time_old_100ms+0x3>
 4f6:	01 96       	adiw	r24, 0x01	; 1
 4f8:	a1 1d       	adc	r26, r1
 4fa:	b1 1d       	adc	r27, r1
 4fc:	80 93 18 01 	sts	0x0118, r24	; 0x800118 <time_old_100ms>
 500:	90 93 19 01 	sts	0x0119, r25	; 0x800119 <time_old_100ms+0x1>
 504:	a0 93 1a 01 	sts	0x011A, r26	; 0x80011a <time_old_100ms+0x2>
 508:	b0 93 1b 01 	sts	0x011B, r27	; 0x80011b <time_old_100ms+0x3>
 50c:	80 91 14 01 	lds	r24, 0x0114	; 0x800114 <time_200ms>
 510:	90 91 15 01 	lds	r25, 0x0115	; 0x800115 <time_200ms+0x1>
			time_200ms++;
 514:	a0 91 16 01 	lds	r26, 0x0116	; 0x800116 <time_200ms+0x2>
 518:	b0 91 17 01 	lds	r27, 0x0117	; 0x800117 <time_200ms+0x3>
 51c:	01 96       	adiw	r24, 0x01	; 1
 51e:	a1 1d       	adc	r26, r1
 520:	b1 1d       	adc	r27, r1
 522:	80 93 14 01 	sts	0x0114, r24	; 0x800114 <time_200ms>
 526:	90 93 15 01 	sts	0x0115, r25	; 0x800115 <time_200ms+0x1>
 52a:	a0 93 16 01 	sts	0x0116, r26	; 0x800116 <time_200ms+0x2>
 52e:	b0 93 17 01 	sts	0x0117, r27	; 0x800117 <time_200ms+0x3>
 532:	80 91 10 01 	lds	r24, 0x0110	; 0x800110 <test_timer1>
 536:	90 91 11 01 	lds	r25, 0x0111	; 0x800111 <test_timer1+0x1>
			test_timer1++;
 53a:	a0 91 12 01 	lds	r26, 0x0112	; 0x800112 <test_timer1+0x2>
 53e:	b0 91 13 01 	lds	r27, 0x0113	; 0x800113 <test_timer1+0x3>
 542:	01 96       	adiw	r24, 0x01	; 1
 544:	a1 1d       	adc	r26, r1
 546:	b1 1d       	adc	r27, r1
 548:	80 93 10 01 	sts	0x0110, r24	; 0x800110 <test_timer1>
 54c:	90 93 11 01 	sts	0x0111, r25	; 0x800111 <test_timer1+0x1>
 550:	a0 93 12 01 	sts	0x0112, r26	; 0x800112 <test_timer1+0x2>
 554:	b0 93 13 01 	sts	0x0113, r27	; 0x800113 <test_timer1+0x3>
 558:	2c b1       	in	r18, 0x0c	; 12
 55a:	80 b1       	in	r24, 0x00	; 0
 55c:	90 e0       	ldi	r25, 0x00	; 0
			
			if (FUSES_ALL_IN){	
 55e:	98 2f       	mov	r25, r24
 560:	88 27       	eor	r24, r24
 562:	9f 70       	andi	r25, 0x0F	; 15
 564:	82 2b       	or	r24, r18
 566:	8f 3f       	cpi	r24, 0xFF	; 255
 568:	9f 40       	sbci	r25, 0x0F	; 15
 56a:	11 f4       	brne	.+4      	; 0x570 <__LOCK_REGION_LENGTH__+0x170>
 56c:	fa d0       	rcall	.+500    	; 0x762 <fault_not_detected>
				fault_not_detected();																					
 56e:	01 c0       	rjmp	.+2      	; 0x572 <__LOCK_REGION_LENGTH__+0x172>
 570:	fc d0       	rcall	.+504    	; 0x76a <fault_detected>
			}																															
			else{
				fault_detected();	
 572:	80 e0       	ldi	r24, 0x00	; 0
			} 
	//MOVE THESE NOTES TO THE MAIN DESCRIPTION THAT WILL COME ON TOP OF THE C FILE JUST LIKE IN THE FAN POWER UNIT 					
//fuse_read_out()&0xff;			// input &0xff gives you the first byte (8bit) (least significant byte)  
//(fuse_read_out()>>8)&0xff;		//shifting 1 byte to the right gives us the next 8 bit bundle, now we've read the full 16 bit value

 			Fusebox0_databytes[0]	=	adc_get(0)&0xff			;
 574:	fd dd       	rcall	.-1030   	; 0x170 <adc_get>
 576:	8e 83       	std	Y+6, r24	; 0x06
 578:	80 e0       	ldi	r24, 0x00	; 0
			Fusebox0_databytes[1]	=	(adc_get(0)>>8)&0xff	;	
 57a:	fa dd       	rcall	.-1036   	; 0x170 <adc_get>
 57c:	9f 83       	std	Y+7, r25	; 0x07
 57e:	81 e0       	ldi	r24, 0x01	; 1
 580:	f7 dd       	rcall	.-1042   	; 0x170 <adc_get>
 			Fusebox0_databytes[2]	=	adc_get(1)&0xff			;	
 582:	88 87       	std	Y+8, r24	; 0x08
 584:	81 e0       	ldi	r24, 0x01	; 1
 586:	f4 dd       	rcall	.-1048   	; 0x170 <adc_get>
 588:	99 87       	std	Y+9, r25	; 0x09
 			Fusebox0_databytes[3]	=	(adc_get(1)>>8)&0xff	; 
 58a:	1a 86       	std	Y+10, r1	; 0x0a
 58c:	1b 86       	std	Y+11, r1	; 0x0b
 58e:	1c 86       	std	Y+12, r1	; 0x0c
			Fusebox0_databytes[4]	=	0						;
 590:	1d 86       	std	Y+13, r1	; 0x0d
			Fusebox0_databytes[5]	=	0						;
 592:	be 01       	movw	r22, r28
 			Fusebox0_databytes[6]	=	0						;
 594:	6a 5f       	subi	r22, 0xFA	; 250
			Fusebox0_databytes[7]	=	0						;
			
			
			
 			
			can_tx(&can_Fusebox0_mob, Fusebox0_databytes); 
 596:	7f 4f       	sbci	r23, 0xFF	; 255
 598:	ce 01       	movw	r24, r28
 59a:	01 96       	adiw	r24, 0x01	; 1
 59c:	a4 de       	rcall	.-696    	; 0x2e6 <can_tx>
 59e:	be 01       	movw	r22, r28
 5a0:	63 5d       	subi	r22, 0xD3	; 211
			 
			//can_rx(&can_R2D_mob, R2D_databytes);
			can_rx(&can_SHB0_mob, SHB0_databytes);
 5a2:	7f 4f       	sbci	r23, 0xFF	; 255
 5a4:	ce 01       	movw	r24, r28
 5a6:	88 96       	adiw	r24, 0x28	; 40
 5a8:	48 de       	rcall	.-880    	; 0x23a <can_rx>
 5aa:	be 01       	movw	r22, r28
 5ac:	60 5e       	subi	r22, 0xE0	; 224
			can_rx(&can_SHR0_mob, SHR0_databytes); //recieve at same freq as sender right?
 5ae:	7f 4f       	sbci	r23, 0xFF	; 255
 5b0:	ce 01       	movw	r24, r28
 5b2:	4b 96       	adiw	r24, 0x1b	; 27
 5b4:	42 de       	rcall	.-892    	; 0x23a <can_rx>
 5b6:	be 01       	movw	r22, r28
 5b8:	66 5c       	subi	r22, 0xC6	; 198
 5ba:	7f 4f       	sbci	r23, 0xFF	; 255
			can_rx(&can_DIC0_mob, DIC0_databytes);
 5bc:	ce 01       	movw	r24, r28
 5be:	c5 96       	adiw	r24, 0x35	; 53
 5c0:	3c de       	rcall	.-904    	; 0x23a <can_rx>
 5c2:	2c b1       	in	r18, 0x0c	; 12
 5c4:	80 b1       	in	r24, 0x00	; 0
 5c6:	90 e0       	ldi	r25, 0x00	; 0
 5c8:	98 2f       	mov	r25, r24
			
		//	R2D_pressed = R2D_databytes[2];
											// define CAR_IS_READY_TO_DRIVE [combines the 3 conditions]
			if ((fuse_read_out() & 0xFFF) < 0xFFF){  //debugging purposes fuse acts as my switch, NO MACRO NOW THE 3 CONDITIONS COME HERE: READY TO DRIVE, POWER ON and BUTTON PRESSED?
 5ca:	88 27       	eor	r24, r24
 5cc:	9f 70       	andi	r25, 0x0F	; 15
 5ce:	82 2b       	or	r24, r18
 5d0:	8f 3f       	cpi	r24, 0xFF	; 255
 5d2:	9f 40       	sbci	r25, 0x0F	; 15
 5d4:	28 f4       	brcc	.+10     	; 0x5e0 <__LOCK_REGION_LENGTH__+0x1e0>
 5d6:	e0 eb       	ldi	r30, 0xB0	; 176
 5d8:	f0 e0       	ldi	r31, 0x00	; 0
 5da:	80 81       	ld	r24, Z
 5dc:	84 60       	ori	r24, 0x04	; 4
 					START_TIMER_2; 				
 5de:	80 83       	st	Z, r24
 5e0:	80 91 26 01 	lds	r24, 0x0126	; 0x800126 <r2d_length>
 5e4:	90 91 27 01 	lds	r25, 0x0127	; 0x800127 <r2d_length+0x1>
			}  

				//define SOUND_STILL_GOING? r2dl < xxx  // <= make that macro and a function that caclulates the time or soemthing, input time in seconds (1-3s) and it will calculate the value for the condition 2,5 seconds = 23000 or something (need to measure it better)
			if (r2d_length < 23000/*<noise_length (change r2dlength to something like r2d_ticks*/){ // under 3 seconds (tested with a stopwatch) as long as the button is not held longer than a singular press => will lead into a 2nd cycle starting 
 5e8:	a0 91 28 01 	lds	r26, 0x0128	; 0x800128 <r2d_length+0x2>
 5ec:	b0 91 29 01 	lds	r27, 0x0129	; 0x800129 <r2d_length+0x3>
 5f0:	88 3d       	cpi	r24, 0xD8	; 216
 5f2:	99 45       	sbci	r25, 0x59	; 89
 5f4:	a1 05       	cpc	r26, r1
 5f6:	b1 05       	cpc	r27, r1
 5f8:	a0 f4       	brcc	.+40     	; 0x622 <__LOCK_REGION_LENGTH__+0x222>
 5fa:	80 91 25 01 	lds	r24, 0x0125	; 0x800125 <note_length>
 5fe:	8f 5f       	subi	r24, 0xFF	; 255
 600:	80 93 25 01 	sts	0x0125, r24	; 0x800125 <note_length>
									
				note_length++;
 604:	85 30       	cpi	r24, 0x05	; 5
 606:	39 f4       	brne	.+14     	; 0x616 <__LOCK_REGION_LENGTH__+0x216>
 608:	10 92 25 01 	sts	0x0125, r1	; 0x800125 <note_length>

 				if (note_length == 5){
 60c:	80 91 24 01 	lds	r24, 0x0124	; 0x800124 <note_next>
				note_length = 0;
 610:	8f 5f       	subi	r24, 0xFF	; 255
 612:	80 93 24 01 	sts	0x0124, r24	; 0x800124 <note_next>
 				note_next++;
 616:	80 91 24 01 	lds	r24, 0x0124	; 0x800124 <note_next>
 61a:	8a 30       	cpi	r24, 0x0A	; 10
 61c:	11 f4       	brne	.+4      	; 0x622 <__LOCK_REGION_LENGTH__+0x222>
				}
 				if (note_next == 10){
 61e:	10 92 24 01 	sts	0x0124, r1	; 0x800124 <note_next>
 622:	80 91 26 01 	lds	r24, 0x0126	; 0x800126 <r2d_length>
 				note_next = 0;
 626:	90 91 27 01 	lds	r25, 0x0127	; 0x800127 <r2d_length+0x1>
 				}	
			}	
			if (r2d_length >= 23000){   //turn into an else{}
 62a:	a0 91 28 01 	lds	r26, 0x0128	; 0x800128 <r2d_length+0x2>
 62e:	b0 91 29 01 	lds	r27, 0x0129	; 0x800129 <r2d_length+0x3>
 632:	88 3d       	cpi	r24, 0xD8	; 216
 634:	99 45       	sbci	r25, 0x59	; 89
 636:	a1 05       	cpc	r26, r1
 638:	b1 05       	cpc	r27, r1
 63a:	78 f0       	brcs	.+30     	; 0x65a <__LOCK_REGION_LENGTH__+0x25a>
 63c:	e0 eb       	ldi	r30, 0xB0	; 176
 63e:	f0 e0       	ldi	r31, 0x00	; 0
 640:	80 81       	ld	r24, Z
 642:	8b 7f       	andi	r24, 0xFB	; 251
				TCCR2A &= ~(1<<CS22);
 644:	80 83       	st	Z, r24
 646:	10 92 26 01 	sts	0x0126, r1	; 0x800126 <r2d_length>
 64a:	10 92 27 01 	sts	0x0127, r1	; 0x800127 <r2d_length+0x1>
				r2d_length = 0;
 64e:	10 92 28 01 	sts	0x0128, r1	; 0x800128 <r2d_length+0x2>
 652:	10 92 29 01 	sts	0x0129, r1	; 0x800129 <r2d_length+0x3>
 656:	10 92 24 01 	sts	0x0124, r1	; 0x800124 <note_next>
 65a:	80 91 18 01 	lds	r24, 0x0118	; 0x800118 <time_old_100ms>
				note_next = 0;
 65e:	90 91 19 01 	lds	r25, 0x0119	; 0x800119 <time_old_100ms+0x1>
			}
	
		}	//end of 10 ms cycle
	
		if (/*time_old_100ms >= 100*/TIME_PASSED_100_MS){ //100 ms
 662:	a0 91 1a 01 	lds	r26, 0x011A	; 0x80011a <time_old_100ms+0x2>
 666:	b0 91 1b 01 	lds	r27, 0x011B	; 0x80011b <time_old_100ms+0x3>
 66a:	84 36       	cpi	r24, 0x64	; 100
 66c:	91 05       	cpc	r25, r1
 66e:	a1 05       	cpc	r26, r1
 670:	b1 05       	cpc	r27, r1
 672:	60 f0       	brcs	.+24     	; 0x68c <__LOCK_REGION_LENGTH__+0x28c>
 674:	10 92 18 01 	sts	0x0118, r1	; 0x800118 <time_old_100ms>
 678:	10 92 19 01 	sts	0x0119, r1	; 0x800119 <time_old_100ms+0x1>
 			time_old_100ms = 0;
 67c:	10 92 1a 01 	sts	0x011A, r1	; 0x80011a <time_old_100ms+0x2>
 680:	10 92 1b 01 	sts	0x011B, r1	; 0x80011b <time_old_100ms+0x3>
 684:	44 d0       	rcall	.+136    	; 0x70e <sys_tick_heart>
 686:	8d e0       	ldi	r24, 0x0D	; 13
 688:	80 93 0b 01 	sts	0x010B, r24	; 0x80010b <fan_duty>
 			sys_tick_heart();  //remove the sys_, tick_heart obvious by itself
 68c:	80 91 14 01 	lds	r24, 0x0114	; 0x800114 <time_200ms>
 			//for (x = 5; x < 90; x++){  //testing the range of values to alter the duty%
 				//int16_t CAN_temperature = x; //from can
 				uint8_t temperature = x;//(uint8_t) CAN_temperature;
 				//_delay_ms(1);   //use sys timer later
 			//	fan_power_unit_PWM_control(temperature, fan_duty); 	
			 fan_duty = (temperature*63)/100;
 690:	90 91 15 01 	lds	r25, 0x0115	; 0x800115 <time_200ms+0x1>
 			//} //end of for
 		}  //end of 100ms
		if (time_200ms >= 20){
 694:	a0 91 16 01 	lds	r26, 0x0116	; 0x800116 <time_200ms+0x2>
 698:	b0 91 17 01 	lds	r27, 0x0117	; 0x800117 <time_200ms+0x3>
 69c:	44 97       	sbiw	r24, 0x14	; 20
 69e:	a1 05       	cpc	r26, r1
 6a0:	b1 05       	cpc	r27, r1
 6a2:	08 f4       	brcc	.+2      	; 0x6a6 <__LOCK_REGION_LENGTH__+0x2a6>
 6a4:	fc ce       	rjmp	.-520    	; 0x49e <__LOCK_REGION_LENGTH__+0x9e>
 6a6:	10 92 14 01 	sts	0x0114, r1	; 0x800114 <time_200ms>
 6aa:	10 92 15 01 	sts	0x0115, r1	; 0x800115 <time_200ms+0x1>
			time_200ms = 0;
 6ae:	10 92 16 01 	sts	0x0116, r1	; 0x800116 <time_200ms+0x2>
 6b2:	10 92 17 01 	sts	0x0117, r1	; 0x800117 <time_200ms+0x3>
 6b6:	86 b1       	in	r24, 0x06	; 6
 6b8:	8b 8b       	std	Y+19, r24	; 0x13
 6ba:	1c 8a       	std	Y+20, r1	; 0x14
 6bc:	80 b1       	in	r24, 0x00	; 0
			
			Fusebox1_databytes[0]	=	SCI_read_out()			;
 6be:	8c b1       	in	r24, 0x0c	; 12
 6c0:	8d 8b       	std	Y+21, r24	; 0x15
			Fusebox1_databytes[1]	= 0;
			Fusebox1_databytes[2]	=	fuse_read_out()&0xff		;
 6c2:	9c b1       	in	r25, 0x0c	; 12
 6c4:	80 b1       	in	r24, 0x00	; 0
 6c6:	89 2b       	or	r24, r25
			Fusebox1_databytes[3]	=	(fuse_read_out()>>8)&0xff	;
 6c8:	8e 8b       	std	Y+22, r24	; 0x16
 6ca:	1f 8a       	std	Y+23, r1	; 0x17
 6cc:	18 8e       	std	Y+24, r1	; 0x18
 6ce:	19 8e       	std	Y+25, r1	; 0x19
			Fusebox1_databytes[4]	= 0;
 6d0:	1a 8e       	std	Y+26, r1	; 0x1a
			Fusebox1_databytes[5]	= 0;
 6d2:	be 01       	movw	r22, r28
			Fusebox1_databytes[6]	= 0;
 6d4:	6d 5e       	subi	r22, 0xED	; 237
			Fusebox1_databytes[7]	= 0;
 6d6:	7f 4f       	sbci	r23, 0xFF	; 255
			
			can_tx(&can_Fusebox1_mob, Fusebox1_databytes);
 6d8:	ce 01       	movw	r24, r28
 6da:	0e 96       	adiw	r24, 0x0e	; 14
 6dc:	04 de       	rcall	.-1016   	; 0x2e6 <can_tx>
 6de:	df ce       	rjmp	.-578    	; 0x49e <__LOCK_REGION_LENGTH__+0x9e>

000006e0 <port_config>:
#include <avr/interrupt.h>

volatile unsigned long sys_time = 0;

void port_config(){  //0 input, 1 output
	DDRA = 0;   //Fuse Read Out Inputs
 6e0:	11 b8       	out	0x01, r1	; 1
	DDRB = 0 | (1<<PB0) |(1<<PB2) | (1<<PB3) | (1<<PB4) | (1<<PB5); //WP, fan and LED outputs
 6e2:	8d e3       	ldi	r24, 0x3D	; 61
 6e4:	84 b9       	out	0x04, r24	; 4
	DDRC = 0; // Shutdown circuit just like FRO is an input 
 6e6:	17 b8       	out	0x07, r1	; 7
	DDRD = 0 | (1<<PD2) | (1<<PD3) | (1<<PD5); /*| (1<<PD6);SET TO 0?*/ // timer for the buzzer and can outputs, PD5 transmits to CAN, PD6 is a receiver
 6e8:	8c e2       	ldi	r24, 0x2C	; 44
 6ea:	8a b9       	out	0x0a, r24	; 10
	DDRE = 0; //Fuse Read Out Inputs
 6ec:	1d b8       	out	0x0d, r1	; 13
	DDRF = 0; //JTAG and 2 ADC readings inputs
 6ee:	10 ba       	out	0x10, r1	; 16
 6f0:	08 95       	ret

000006f2 <sys_timer_config>:
}

void sys_timer_config(){  
	TCCR0A |= (1<<WGM01); //CTC mode
 6f2:	84 b5       	in	r24, 0x24	; 36
 6f4:	88 60       	ori	r24, 0x08	; 8
 6f6:	84 bd       	out	0x24, r24	; 36
	TCCR0A |= (1<<CS01) | (1<<CS00); //prescaler 64 => page 111
 6f8:	84 b5       	in	r24, 0x24	; 36
 6fa:	83 60       	ori	r24, 0x03	; 3
 6fc:	84 bd       	out	0x24, r24	; 36
	TIMSK0 |= (1<<OCF0A);  //interrupt flags enable
 6fe:	ee e6       	ldi	r30, 0x6E	; 110
 700:	f0 e0       	ldi	r31, 0x00	; 0
 702:	80 81       	ld	r24, Z
 704:	82 60       	ori	r24, 0x02	; 2
 706:	80 83       	st	Z, r24
	OCR0A = 124;  //TOP for 1ms   => 16000000/2*64*(1+124) = 1000 Hz
 708:	8c e7       	ldi	r24, 0x7C	; 124
 70a:	87 bd       	out	0x27, r24	; 39
 70c:	08 95       	ret

0000070e <sys_tick_heart>:
}

void sys_tick_heart(){
	PORTB ^= (1<<PB4); //toggle the Heart led on Pin 4, will be used in the super loop in main.c to indicade that the loop is running correctly	
 70e:	95 b1       	in	r25, 0x05	; 5
 710:	80 e1       	ldi	r24, 0x10	; 16
 712:	89 27       	eor	r24, r25
 714:	85 b9       	out	0x05, r24	; 5
 716:	08 95       	ret

00000718 <__vector_16>:
};

ISR(TIMER0_COMP_vect){
 718:	1f 92       	push	r1
 71a:	0f 92       	push	r0
 71c:	0f b6       	in	r0, 0x3f	; 63
 71e:	0f 92       	push	r0
 720:	11 24       	eor	r1, r1
 722:	8f 93       	push	r24
 724:	9f 93       	push	r25
 726:	af 93       	push	r26
 728:	bf 93       	push	r27
//	cli();
	sys_time++;  //system time incremented on each interrupt flag from the CTC mode compare register => every OCR0A
 72a:	80 91 20 01 	lds	r24, 0x0120	; 0x800120 <sys_time>
 72e:	90 91 21 01 	lds	r25, 0x0121	; 0x800121 <sys_time+0x1>
 732:	a0 91 22 01 	lds	r26, 0x0122	; 0x800122 <sys_time+0x2>
 736:	b0 91 23 01 	lds	r27, 0x0123	; 0x800123 <sys_time+0x3>
 73a:	01 96       	adiw	r24, 0x01	; 1
 73c:	a1 1d       	adc	r26, r1
 73e:	b1 1d       	adc	r27, r1
 740:	80 93 20 01 	sts	0x0120, r24	; 0x800120 <sys_time>
 744:	90 93 21 01 	sts	0x0121, r25	; 0x800121 <sys_time+0x1>
 748:	a0 93 22 01 	sts	0x0122, r26	; 0x800122 <sys_time+0x2>
 74c:	b0 93 23 01 	sts	0x0123, r27	; 0x800123 <sys_time+0x3>
//	sei();
}
 750:	bf 91       	pop	r27
 752:	af 91       	pop	r26
 754:	9f 91       	pop	r25
 756:	8f 91       	pop	r24
 758:	0f 90       	pop	r0
 75a:	0f be       	out	0x3f, r0	; 63
 75c:	0f 90       	pop	r0
 75e:	1f 90       	pop	r1
 760:	18 95       	reti

00000762 <fault_not_detected>:

void fault_not_detected(){	
	PORTB &= ~(1<<PB3); //turn off red led in case of no fault
 762:	85 b1       	in	r24, 0x05	; 5
 764:	87 7f       	andi	r24, 0xF7	; 247
 766:	85 b9       	out	0x05, r24	; 5
 768:	08 95       	ret

0000076a <fault_detected>:
}
void fault_detected(){
	PORTB |= (1<<PB3); //turn on red led when called (fault present)
 76a:	85 b1       	in	r24, 0x05	; 5
 76c:	88 60       	ori	r24, 0x08	; 8
 76e:	85 b9       	out	0x05, r24	; 5
 770:	08 95       	ret

00000772 <timer2_config>:
		if (note_length == 5){
			note_length = 0;
			note_next++;
		}
		if (note_next == 10){
			note_next = 0;
 772:	e0 eb       	ldi	r30, 0xB0	; 176
 774:	f0 e0       	ldi	r31, 0x00	; 0
 776:	80 81       	ld	r24, Z
 778:	88 60       	ori	r24, 0x08	; 8
 77a:	80 83       	st	Z, r24
 77c:	82 e0       	ldi	r24, 0x02	; 2
 77e:	80 93 70 00 	sts	0x0070, r24	; 0x800070 <__TEXT_REGION_LENGTH__+0x7e0070>
 782:	08 95       	ret

00000784 <__vector_9>:
		}
}

ISR(TIMER2_COMP_vect){ //isr for timer2 
 784:	1f 92       	push	r1
 786:	0f 92       	push	r0
 788:	0f b6       	in	r0, 0x3f	; 63
 78a:	0f 92       	push	r0
 78c:	11 24       	eor	r1, r1
 78e:	0b b6       	in	r0, 0x3b	; 59
 790:	0f 92       	push	r0
 792:	8f 93       	push	r24
 794:	9f 93       	push	r25
 796:	af 93       	push	r26
 798:	bf 93       	push	r27
 79a:	ef 93       	push	r30
 79c:	ff 93       	push	r31
	//cli(); // if cli() and sei() at the end are deployed, the code slows down immensly (longer sounds etc, but the overall r2d length does not get affected at all since its inside the ISR)
	PORTD ^= (1<<PD2);
 79e:	9b b1       	in	r25, 0x0b	; 11
 7a0:	84 e0       	ldi	r24, 0x04	; 4
 7a2:	89 27       	eor	r24, r25
 7a4:	8b b9       	out	0x0b, r24	; 11
	OCR2A = song[note_next];
 7a6:	e0 91 24 01 	lds	r30, 0x0124	; 0x800124 <note_next>
 7aa:	f0 e0       	ldi	r31, 0x00	; 0
 7ac:	e0 50       	subi	r30, 0x00	; 0
 7ae:	ff 4f       	sbci	r31, 0xFF	; 255
 7b0:	80 81       	ld	r24, Z
 7b2:	80 93 b3 00 	sts	0x00B3, r24	; 0x8000b3 <__TEXT_REGION_LENGTH__+0x7e00b3>
	r2d_length++;
 7b6:	80 91 26 01 	lds	r24, 0x0126	; 0x800126 <r2d_length>
 7ba:	90 91 27 01 	lds	r25, 0x0127	; 0x800127 <r2d_length+0x1>
 7be:	a0 91 28 01 	lds	r26, 0x0128	; 0x800128 <r2d_length+0x2>
 7c2:	b0 91 29 01 	lds	r27, 0x0129	; 0x800129 <r2d_length+0x3>
 7c6:	01 96       	adiw	r24, 0x01	; 1
 7c8:	a1 1d       	adc	r26, r1
 7ca:	b1 1d       	adc	r27, r1
 7cc:	80 93 26 01 	sts	0x0126, r24	; 0x800126 <r2d_length>
 7d0:	90 93 27 01 	sts	0x0127, r25	; 0x800127 <r2d_length+0x1>
 7d4:	a0 93 28 01 	sts	0x0128, r26	; 0x800128 <r2d_length+0x2>
 7d8:	b0 93 29 01 	sts	0x0129, r27	; 0x800129 <r2d_length+0x3>
	//sei(); //magic?
 7dc:	ff 91       	pop	r31
 7de:	ef 91       	pop	r30
 7e0:	bf 91       	pop	r27
 7e2:	af 91       	pop	r26
 7e4:	9f 91       	pop	r25
 7e6:	8f 91       	pop	r24
 7e8:	0f 90       	pop	r0
 7ea:	0b be       	out	0x3b, r0	; 59
 7ec:	0f 90       	pop	r0
 7ee:	0f be       	out	0x3f, r0	; 63
 7f0:	0f 90       	pop	r0
 7f2:	1f 90       	pop	r1
 7f4:	18 95       	reti

000007f6 <_exit>:
 7f6:	f8 94       	cli

000007f8 <__stop_program>:
 7f8:	ff cf       	rjmp	.-2      	; 0x7f8 <__stop_program>
